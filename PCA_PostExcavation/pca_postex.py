# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PCA_PostExc
                                 A QGIS plugin
 This plugin helps during the postex phase
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-08-25
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Valerio Pinna
        email                : pinnavalerio@yahoo.co.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import time
import os.path
import inspect
import processing
from datetime import date, datetime
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon, QKeySequence
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QToolBar, QShortcut, QProgressBar
from qgis.core import *
from qgis.utils import iface
from PyQt5 import QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QDialog

from PyQt5.QtWidgets import QShortcut




# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .pca_postex_dialog import PCA_PostExcDialog
from .pca_postex_update_DRS_dialog import PCA_PostExc_updateDRS_Dialog
from .pca_postex_generate_layer_dialog import PCA_PostExc_GenerateLayer_Dialog
from .pca_postex_export_to_access_dialog import PCA_PostExc_ExportToAccess_Dialog




cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

class PCA_PostExc:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PCA_PostExc_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&PCA PostExcavation')
        
        # Test ## Add dialogues istances
        self.dlg = PCA_PostExcDialog()        
        self.dlgtool2 = PCA_PostExc_updateDRS_Dialog()
        self.dlgtool3 = PCA_PostExc_GenerateLayer_Dialog()
        self.dlgtool4 = PCA_PostExc_ExportToAccess_Dialog()
        
        self.toolbar = iface.mainWindow().findChild( QToolBar, u'PCA PostExcavation Toolbar' )
        if not self.toolbar:
            self.toolbar = iface.addToolBar( u'PCA PostExcavation Toolbar' )
            self.toolbar.setObjectName( u'PCA PostExcavation Toolbar' )
            self.toolbar.setToolTip("")
        
        
        self.dlgtool4.Tables_on_GIS_comboBox.setFilters(QgsMapLayerProxyModel.NoGeometry ) 
        
        
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PCA_PostExc', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            #self.iface.addToolBarIcon(action)
            self.toolbar.addAction(action)
            
        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""       
            
        self.PCAlogo= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/pca_logo_icon.png',
            text=self.tr(u''),
            callback=self.dontdonothing,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
       
        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/PCA_postex_layer_generator_icon.png',
            text=self.tr(u'Generate the PCA post-excavation layer'),
            callback=self.generate_postex_layer,
            parent=self.iface.mainWindow())     
        # will be set False in generate_postex_layer()
        self.first_start = True
        
        self.changeattributes= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/PCA_postex_change_attribute_icon.png',
            text=self.tr(u'Add post-excavation attributes to selected features'),
            callback=self.change_attributes,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        self.reapply_style= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/PCA_postex_reapply_style_icon.png',
            text=self.tr(u'Re-apply the Period Colours Style'),
            callback=self.reapply_period_style,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        self.cleanrules= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/PCA_postex_clean_rules_icon.png',
            text=self.tr(u'Remove empty periods from the symbology'),
            callback=self.clean_empty_rules,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        self.updateDRS= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/PCA_postex_update_DRS_icon.png',
            text=self.tr(u'Update the DRS spreadsheet with the post-excavation information'),
            callback=self.update_DRS_table,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        
        self.exportforAccess= self.add_action( 
            icon_path = ':/plugins/pca_postex/icons/PCA_postex_export_to_access_icon.png',
            text=self.tr(u'Export a formatted version of the DRS spreadsheet that can be imported on Access'),
            callback=self.export_table_for_access,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&PCA PostExcavation'),
                action)
            self.iface.removeToolBarIcon(action)
            
    def group_names_list(self):
        group_names_list = ['','Ditch', 'Mound', 'Roundhouse','SFB','Structure','Kiln','Corn Dryer','Pond','Well / Waterhole','Bedding Trench','Furrow','Pit Cluster','Pit Alignment','Pit Group','Surface','Fence Line','Inhumation Burial','Cremation Burial','Oven','Deposit']
        
        self.dlg.group_name_comboBox.clear()
        self.dlg.group_name_comboBox.addItems(group_names_list)
        
    def entity_names_list(self):
        entity_names_list = ['','Cemetery','Field System','Enclosure', 'Linear Boundary','Road/Trackway','Monument', 'Palaeochannel' ]
        
        self.dlg.entity_name_comboBox.clear()
        self.dlg.entity_name_comboBox.addItems(entity_names_list)
        
    def period_list(self):
        period_list = ['','Neolithic', 'Bronze Age', 'Iron Age', 'Roman', 'Saxon', 'Medieval', 'Post Medieval', 'Modern']

        self.dlg.period_comboBox.clear()
        self.dlg.period_comboBox.addItems(period_list)

    def subperiod_list_changed(self):
        ch_period = self.dlg.period_comboBox.currentText()
        global sub_neolithic_list
        sub_neolithic_list = ['','Early Neolithic', 'Middle Neolithic', 'Late Neolithic']
        global sub_bronze_age_list
        sub_bronze_age_list = ['','Early Bronze Age', 'Middle Bronze Age', 'Late Bronze Age']
        global sub_iron_age_list
        sub_iron_age_list = ['','Early Iron Age','Middle Iron Age','Late Iron Age']
        global sub_roman_list
        sub_roman_list = ['','Early Roman', 'Middle Roman','Late Roman']
        global sub_saxon_list
        sub_saxon_list = ['','Early Saxon','Middle Saxon','Late Saxon']
        global sub_medieval_list
        sub_medieval_list = ['','Anglo-Norman/Early Medieval','High Medieval','Late Medieval']
        global sub_postmedieval_list
        sub_postmedieval_list = ['', 'Early Post Medieval', 'Middle Post Medieval', 'Late Post Medieval']
        global sub_modern_list
        sub_modern_list = ['']

        if ch_period == 'Neolithic':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_neolithic_list)
            
        if ch_period == 'Bronze Age':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_bronze_age_list)

        if ch_period == 'Iron Age':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_iron_age_list)
        
        if ch_period == 'Roman':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_roman_list)
        
        if ch_period == 'Saxon':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_saxon_list)
            
        if ch_period == 'Medieval':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_medieval_list)
        
        if ch_period == 'Post Medieval':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_postmedieval_list)
            
        if ch_period == 'Modern':
            self.dlg.sub_period_comboBox.clear()
            self.dlg.sub_period_comboBox.addItems(sub_modern_list)
                   
    def change_period_number(self):
        ch_period = self.dlg.period_comboBox.currentText()
        if ch_period == 0:
            return self.dontdonothing
        if ch_period == '':
            self.dlg.period_number_comboBox.clear()
            return self.dontdonothing
        else:
            
            period_list = ['Neolithic', 'Bronze Age', 'Iron Age', 'Roman', 'Saxon', 'Medieval', 'Post Medieval', 'Modern']
            ch_period_number = str(period_list.index(ch_period)+1)

            ch_period_number_list = []
            ch_period_number_list.append(ch_period_number)
            self.dlg.period_number_comboBox.clear()
            self.dlg.period_number_comboBox.addItems(ch_period_number_list)     
            
    def change_subperiod_number(self):
        ch_period = self.dlg.period_comboBox.currentText()
        period_number = self.dlg.period_number_comboBox.currentText() 
        ch_subperiod = self.dlg.sub_period_comboBox.currentText()
        
        if ch_subperiod == 0:
            return self.dontdonothing
        else:

            AllItems = [self.dlg.sub_period_comboBox.itemText(i) for i in range(self.dlg.sub_period_comboBox.count())]
            if len(AllItems) == 0: 
                return self.dontdonothing
            else:
                if ch_subperiod == '':
                    self.dlg.subperiod_number_comboBox.clear()
                if ch_subperiod != '':
                
                
                    ch_subperiod_number = str(AllItems.index(ch_subperiod))
                    if ch_subperiod_number == 0:
                        return self.dontdonothing
                    else:
                        ch_subperiod_number_final = period_number+'.'+ch_subperiod_number
                        ch_subperiod_number_list = []
                        ch_subperiod_number_list.append(ch_subperiod_number_final)
                        self.dlg.subperiod_number_comboBox.clear()
                        self.dlg.subperiod_number_comboBox.addItems(ch_subperiod_number_list)  
                        
    def change_group_number(self):
        ch_group_name = self.dlg.group_name_comboBox.currentText() 
        
        vlayer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        if ch_group_name == '':
            self.dlg.group_number_comboBox.clear()
        if ch_group_name != '':
        
            used_group_list = set()
            for f in vlayer.getFeatures():
                name = f["Group"]
                if name != NULL:
                    used_group_list.add(name)

            filtered_list = []
            for a in used_group_list:
                if a.find(ch_group_name) == 0:
                    filtered_list.append(a)
         
            new_group_number = str((len(filtered_list)+1))
            proposed_group_number_list = []
            proposed_group_number_list.append(new_group_number)
            
            self.dlg.group_number_comboBox.clear()
            self.dlg.group_number_comboBox.addItems(proposed_group_number_list)  
            used_group_list.clear()
            filtered_list.clear()
            
    def change_entity_number(self):
        ch_entity_name = self.dlg.entity_name_comboBox.currentText() 
        
        vlayer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        if ch_entity_name == '':
            self.dlg.entity_number_comboBox.clear()
        if ch_entity_name != '':
        
            used_entity_list = set()
            for f in vlayer.getFeatures():
                name = f["Entity"]
                if name != NULL:
                    used_entity_list.add(name)
                    
            entity_filtered_list = []
            for a in used_entity_list:
                if a.find(ch_entity_name) == 0:
                    entity_filtered_list.append(a)
            
            new_entity_number = str((len(entity_filtered_list)+1))
            proposed_entity_number_list = []
            proposed_entity_number_list.append(new_entity_number)
            
            self.dlg.entity_number_comboBox.clear()
            self.dlg.entity_number_comboBox.addItems(proposed_entity_number_list)  
            used_entity_list.clear()
            entity_filtered_list.clear()
                                  
    def change_attributes(self):
        """Run method that performs all the real work"""
        
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        # if self.first_start == True:
            # self.first_start = False
            
            
            # self.dlg = PCA_PostExcDialog()
        
            

        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            QMessageBox.warning(
            None,
            'PCA PostExcavation Plugin',
            'There is not a valid PostExcavation layer. Use the appropriate tool in this toolbar to generate it and retry.')
        ####ADD CHECK FOR LAYER AND MESSAGE HOW TO CREATE IT#########
        else: 
            layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
            self.period_list()
            self.group_names_list()
            self.entity_names_list()
            

            self.dlg.period_comboBox.currentTextChanged.connect(self.subperiod_list_changed)
            self.dlg.period_comboBox.currentTextChanged.connect(self.change_period_number)
            
            self.dlg.sub_period_comboBox.currentTextChanged.connect(self.change_subperiod_number)
            
            self.dlg.group_name_comboBox.currentTextChanged.connect(self.change_group_number)
            self.dlg.entity_name_comboBox.currentTextChanged.connect(self.change_entity_number)
            
            
            
            # Check, with messages, that at least one feature is selected
            if layer.selectedFeatureCount() == 0:
                QMessageBox.warning(
                None,
                'PCA PostExcavation Plugin',
                'There is no selection. Select at least one feature.')
            if layer.selectedFeatureCount() != 0:
               
                self.entity_names_list()
                self.group_names_list()
                # show the dialog
                #self.dlg = QDialog(iface.mainWindow())
                
                self.dlg.show()
                # Run the dialog event loop
                result = self.dlg.exec_()
                # See if OK was pressed
                if result:
                    # Do something useful here - delete the line containing pass and
                    # substitute with your code.
                    
                    layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
                    
                    period = self.dlg.period_comboBox.currentText()
                    subperiod = self.dlg.sub_period_comboBox.currentText()
                    period_number = self.dlg.period_number_comboBox.currentText()         
                    subperiod_number = self.dlg.subperiod_number_comboBox.currentText()         
                    group_name = self.dlg.group_name_comboBox.currentText()         
                    group_number = self.dlg.group_number_comboBox.currentText()       
                    entity_name = self.dlg.entity_name_comboBox.currentText()         
                    entity_number = self.dlg.entity_number_comboBox.currentText()  
                    phase = self.dlg.phase_comboBox.currentText()        
                    
                    
                    group_value = group_name+' '+group_number
                    
                    entity_value = entity_name+' '+entity_number
                    
                    period_field_idx = layer.fields().indexOf('Period')
                    period_new_value = period

                    sub_period_field_idx = layer.fields().indexOf('SubPeriod')
                    sub_period_new_value = subperiod
                    
                    period_number_field_idx = layer.fields().indexOf('Period_no')
                    period_number_new_value = period_number
                    
                    sub_period_number_field_idx = layer.fields().indexOf('SubPer_no')
                    sub_period_number_new_value = subperiod_number
                    
                    group_field_idx = layer.fields().indexOf('Group')
                    group_new_value = group_value
                    
                    entity_field_idx = layer.fields().indexOf('Entity')
                    
                    phase_field_idx = layer.fields().indexOf('Phase')
                    
                    layer.startEditing()
                    for feat_id in layer.selectedFeatureIds():
                        layer.changeAttributeValue(feat_id, period_field_idx, period_new_value)
                        layer.changeAttributeValue(feat_id, sub_period_field_idx, sub_period_new_value)
                       
                        layer.changeAttributeValue(feat_id, period_number_field_idx, period_number_new_value)
                        layer.changeAttributeValue(feat_id, sub_period_number_field_idx, sub_period_number_new_value)
                       
                        # if len(group_value) < 2:
                            # return self.dontdonothing()
                        if len(group_value) > 3:
                            #for feat_id in layer.selectedFeatureIds():
                            layer.changeAttributeValue(feat_id, group_field_idx, group_new_value)

                        # if len(entity_value) < 2:
                            # return self.dontdonothing()
                        if len(entity_value) > 3:
                            #for feat_id in layer.selectedFeatureIds():
                            layer.changeAttributeValue(feat_id, entity_field_idx, entity_value)
                        
                        # if len(phase) == 0:
                            # return self.dontdonothing()
                        if len(phase) != 0:
                            #for feat_id in layer.selectedFeatureIds():
                            layer.changeAttributeValue(feat_id, phase_field_idx, phase)
                            

                    layer.commitChanges()
                    layer.removeSelection()
                    self.dlg.group_number_comboBox.clear()
                    self.dlg.group_name_comboBox.clear()   
                    self.dlg.entity_number_comboBox.clear()
                    self.dlg.entity_name_comboBox.clear() 
    
    def generate_postex_layer(self):
        if self.first_start == True:
            self.first_start = False
            
  
        # show the dialog
        self.dlgtool3.show()
        # Run the dialog event loop
        result = self.dlgtool3.exec_()
        # See if OK was pressed
        if result:
            #add the action here
            
            root = QgsProject.instance().layerTreeRoot()
            if root.findGroup("Site Plan") is None:
                QMessageBox.about(
                None,
                'PCA PostExcavation Plugin',
                '''This is not a valid PCA QGIS Site Plan Project''')
        
                
                return self.dontdonothing()
                
            else:
                pass
        
            
            #create a new folder
            # Directory
            directory = "PostEx_Layer"

            #Project Folder
            project_dir = QgsProject.instance().homePath() + '/Shapefile/'

            path = os.path.join(project_dir,directory)

            if not os.path.exists(path):
                os.makedirs(path)
            else:
                pass
                
            #create new group


            for child in root.children():
                sitenamegroup = (child.name())
        
                if child.findGroup("PostEx") is None:
                    child.insertGroup(0, "PostEx")    


            #to check if the layer already exists
            file = path+ '/Features_for_PostEx.shp'

            if os.path.exists(file) == True:
                reply = QMessageBox.warning(None,  'PCA PostExcavation Plugin',
                                                    '''The file 'Features_for_PostEx' already exists! \nDo you want to overwrite it? All your previous edits will be lost. \n \nTo overwrite, select YES and delete the old files from the \
                                                    disk (the folder will be open automatically) and then, re-run the plugin.''',
                                                    QMessageBox.Yes, QMessageBox.No)
                if reply == QMessageBox.No: 
                    return self.dontdonothing()
                            
                if reply == QMessageBox.Yes:
                    for lyr in QgsProject.instance().mapLayers().values():
                        if lyr.name() == "Features_for_PostEx":
                            QgsProject.instance().removeMapLayers([lyr.id()])
                    path = os.path.realpath(path)
                    os.startfile(path)
                    # QMessageBox.about(None,'PCA PostExcavation Plugin', 'Manually delete the older files and re-run the plugin')   
                    
                    return self.dontdonothing()

           
            shapefile_list = []

          
            list_of_layers = ['Archaeological_Features', 'Burials', 'Layers', 'Masonry', 'Modern', 'Furrows_and_Ridges' ]
            for e in list_of_layers:
                if QgsProject.instance().mapLayersByName(e):
                    origlayer= QgsProject.instance().mapLayersByName(e)[0]
                    origlayer_path = origlayer.source()
                    shapefile_list.append(origlayer_path)
            
            parameters = {'LAYERS': shapefile_list, 
                          'CRS': 'EPSG:27700', 
                          'OUTPUT': str(path+'/Features_for_PostEx.shp')}

            processing.run("qgis:mergevectorlayers", parameters) 
                
            new_layer = path+'/Features_for_PostEx.shp'
            postexlayer = iface.addVectorLayer(new_layer, "Features_for_PostEx", "ogr")
            if not postexlayer:
                print("Layer failed to load!")

            thelayers = QgsProject.instance().mapLayersByName("Features_for_PostEx")
            thelayer = thelayers[0]
            myblayer = root.findLayer(thelayer.id())
            myClone = myblayer.clone()
            parent = myblayer.parent()
            root.findGroup("PostEx").insertChildNode(1, myClone)
            parent.removeChildNode(myblayer) 

            #expand group
            layeronplace = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
            myLayerNode = root.findLayer(layeronplace.id())
            myLayerNode.setExpanded(True)


            #remove fields
            final_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            caps = final_layer.dataProvider().capabilities()
            
            id_list = []
            fields_list = []
            for field in final_layer.fields():
                fields_list.append(field.name())
            if 'layer' in fields_list:
                fields_list.remove('layer')
  

            for e in fields_list:
                id_list.append(final_layer.fields().indexFromName(e))


            
            res = final_layer.dataProvider().deleteAttributes(id_list)
            
            
            #add new fields
            
            resadd = final_layer.dataProvider()
            resadd.addAttributes([QgsField('Group', QVariant.String, '', 254),
                                  QgsField('Entity', QVariant.String, '', 254),
                                  QgsField('Period', QVariant.String, '', 254),
                                  QgsField('Period_no', QVariant.String, '', 254),
                                  QgsField('SubPeriod', QVariant.String, '', 254),
                                  QgsField('SubPer_no', QVariant.String, '', 254),
                                  QgsField('Phase', QVariant.String, '', 254),
                                  QgsField('Notes', QVariant.String, '', 254)])
              
            
            final_layer.updateFields()  
            
            #add style from file
            
            final_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/PCA_PostExcavation_Features_Style.qml')))    

            iface.mapCanvas().refresh()

            node_group1 = root.findGroup("PostEx")
            node_group1.setExpanded(False) # set as false to remove the false true at the creation
            node_group1.setExpanded(True)
            
            myLayerNode = root.findLayer(final_layer.id())
            myLayerNode.setExpanded(True)

            for e in list_of_layers:
                if QgsProject.instance().mapLayersByName(e):
                    origlayer= QgsProject.instance().mapLayersByName(e)[0]
                    root.findLayer(origlayer.id()).setItemVisibilityCheckedParentRecursive(False)
            
            
            QgsProject.instance().layerTreeRoot().findGroup(sitenamegroup).setItemVisibilityChecked(True)
            QgsProject.instance().layerTreeRoot().findGroup('Site Plan').setItemVisibilityChecked(True)
            
            
            root.findLayer(final_layer.id()).setItemVisibilityCheckedParentRecursive(False)
            root.findLayer(final_layer.id()).setItemVisibilityCheckedParentRecursive(True)

            
            iface.setActiveLayer(final_layer)
            
            QMessageBox.about(
            None,
            'PCA PostExcavation Plugin',
            '''New Post-Excavation layer successfully generated and ready for use''')

    def reapply_period_style(self):
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else: 
            restyle_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            restyle_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/PCA_PostExcavation_Features_Style.qml')))    
            iface.mapCanvas().refresh()
            
    def clean_empty_rules(self):
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else: 
            restyle_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            
            r = restyle_layer.renderer()
            if r.type() == 'RuleRenderer':
                for rule in r.rootRule().children(): # Iterate rules
                    if rule.filter(): # Filter out empty rules
                        request = QgsFeatureRequest( rule.filter() )
                        count = len( [f for f in restyle_layer.getFeatures( request )] )
                        print (rule.label() + ' : ' + str(count))
                        if count == 0:
             
                            r.rootRule().removeChild(rule)

            restyle_layer.triggerRepaint() 
            iface.layerTreeView().refreshLayerSymbology( restyle_layer.id() )
            restyle_layer.emitStyleChanged()

    def update_DRS_table(self):

        # if self.first_start == True:
            # self.first_start = False
            
            
            
        # show the dialog
        self.dlgtool2.show()
        # Run the dialog event loop
        result = self.dlgtool2.exec_()
        # See if OK was pressed
        if result:
            
            
            #add the action here
            
            if len(QgsProject.instance().mapLayersByName('Interventions')) == 0:
                QMessageBox.about(
                None,
                'PCA PostExcavation Plugin',
                '''This is not a valid PCA QGIS Site Plan Project''')
                return self.dontdonothing()
                
            if len(QgsProject.instance().mapLayersByName('Interventions')) != 0:
            
            
                intervention_DRS_layer = QgsProject.instance().mapLayersByName("Interventions")[0]
            
                #Create progress bar
                progressMessageBar = iface.messageBar().createMessage("DRS is being updated...")
                progress = QProgressBar()
                progress.setMaximum(100)
                progress.setAlignment(Qt.AlignLeft|Qt.AlignVCenter)
                progressMessageBar.layout().addWidget(progress)
                iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
                
                
                
                progress.setValue(0)
                
                
                ################################
                ## Intervention layer update ###
                ################################
                
                #check if the group exists and, if not, create it
                caps = intervention_DRS_layer.dataProvider().capabilities()    
                resadd = intervention_DRS_layer.dataProvider()
                            
                group_field_name_list = ["Group","Entity", "Period", "Period Number", "Sub Period","Sub Period Number","Phase"]

                for group_name in group_field_name_list:
                    group_field_name = group_name
                    field_index = intervention_DRS_layer.fields().indexFromName(group_name)
                    if field_index == -1:
                        resadd.addAttributes([QgsField(group_name, QVariant.String, '', 254)])
                    

                intervention_DRS_layer.updateFields()  
                progress.setValue(15)

                #############################

                #add the attributes to Intervention from Features_for_PostEx
                
                
                intervention_DRS_layer.startEditing()

                for group_name in group_field_name_list:

                    if group_name == "Period Number":
                        group_name_contract = "Period_no"
                    elif group_name == 'Sub Period':
                        group_name_contract = 'SubPeriod'
                    elif group_name == 'Sub Period Number':
                        group_name_contract = 'SubPer_no'
                    else:
                        group_name_contract = group_name

                    ###old expression. Creates duplicated value if a slot is below two features (es. ditch and layer) and a false result if a slot has two interventions (es, old cut below all)
                    # e = QgsExpression( '''\
                    # array_to_string(\
                    # array_majority( \
                    # aggregate(\
                    # layer:='Features_for_PostEx',\
                    # aggregate:='array_agg',\
                    # expression:='''+group_name_contract+''',\
                    # filter:=intersects($geometry,buffer(geometry(@parent),-0.01))\
                    # )))\
                    # ''' )
                    
                    e = QgsExpression( '''
                    array_to_string(
                    array_majority( 
                    aggregate(
                    layer:='Features_for_PostEx',
                    aggregate:='array_agg',
                    expression:='''+group_name_contract+''',\
                    filter:=intersects(boundary(buffer($geometry, -0.01)), geometry(@parent))
                    )))
                    ''')

                    context = QgsExpressionContext()
                    context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(intervention_DRS_layer))

                    for f in intervention_DRS_layer.getFeatures():
                        context.setFeature(f)
                        f[group_name] = e.evaluate( context )
                        intervention_DRS_layer.updateFeature(f)


                intervention_DRS_layer.commitChanges()
                progress.setValue(25)
                #######################
                ## DRS Table update ###
                #######################
            
                intervention = QgsProject.instance().mapLayersByName('Interventions')[0]
                DRS_to_update = QgsProject.instance().mapLayersByName('DRS_Table')[0]


                caps = DRS_to_update.dataProvider().capabilities()    
                resadd = DRS_to_update.dataProvider()

                # group_field_name_list = ["Group","Entity", "Period", "Period Number", "Sub Period","Sub Period Number","Phase"]

                for group_name in group_field_name_list:
                    group_field_name = group_name
                    field_index = DRS_to_update.fields().indexFromName(group_name)
                    if field_index == -1:
                        resadd.addAttributes([QgsField(group_name, QVariant.String, '', 254)])

                DRS_to_update.updateFields()  
                
                progress.setValue(30)
                time_value = 30
                for group_name in group_field_name_list:
                    
                    for f in DRS_to_update.getFeatures():
                        cut = f["Cut"]
                        id = f.id()
                        
                        any_group_field_idx = DRS_to_update.fields().indexOf(group_name)
                        
                        exp = QgsExpression('context_no = '+cut)
                        request = QgsFeatureRequest(exp)
                        
                        for fea in intervention.getFeatures(request):
                            group = fea[group_name]

                        DRS_to_update.startEditing()
                        DRS_to_update.selectByExpression("$id ="+ str(id))
                        for feat_id in DRS_to_update.selectedFeatureIds():
                            DRS_to_update.changeAttributeValue(feat_id, any_group_field_idx, group)
                    DRS_to_update.commitChanges()
                    time_value += 10
                    
                    progress.setValue(time_value)
                
                progress.setValue(100)
                iface.messageBar().clearWidgets()
                QMessageBox.about(None,'PCA PostExcavation Plugin', 'The DRS has been successfully updated.')  
                     
    def export_table_for_access(self):
            # show the dialog
        self.dlgtool4.show()
        # Run the dialog event loop
        result = self.dlgtool4.exec_()
        # See if OK was pressed
        if result:
            
            table_to_export = self.dlgtool4.Tables_on_GIS_comboBox.currentLayer() 
            sitecode =  self.dlgtool4.sitecode_textbox.text()
            filename =  table_to_export.name()
            now = datetime.now().strftime("%Y%m%d_%H%M%S")
            if len(table_to_export) == 0:
                QMessageBox.about(None,'PCA PostExcavation Plugin', 'No valid DRS table was selected. Please select a layer.')
                return self.dontdonothing()
             
            else:
                
                    
                # Directory
                CSV_export_directory = "Exported_CSV"

                #Project Folder
                project_dir = QgsProject.instance().homePath() + '/Databases/'

                path = os.path.join(project_dir,CSV_export_directory)

                if not os.path.exists(path):
                    os.makedirs(path)
                else:
                    pass
              
                combined_description_express ='''
                if("Type"='Cut', 
                concat("Shape",', ',replace(lower(regexp_replace("Sides",' ([(].*?[)])','')),',',' and'),' sides',', ',lower("Base"),' base'||' and ', "Orientation" , ' aligned')
                ,
				concat("Compaction",' compaction, ',lower("Tone"),' '||lower("Hue"),' '||lower("Colour"),' ',lower("Composition"),
                if("Significant_ Inclusions" is not null, ' with ', ''),lower("Significant_ Inclusions")))
                '''
                
                if table_to_export.name() == 'DRS_Table':
                    DRS_Field_scheme = [
                    ##add sitecode as first field
                    {'expression': "'"+sitecode+"'",'length': 100,'name': 'Site Code','precision': 0,'type': 10},
                    {'expression': '"Context"','length': 0,'name': 'Context No','precision': 0,'type': 2},
                    {'expression': '"Cut"','length': 0,'name': 'Cut','precision': 0,'type': 2},
                    {'expression': '"Trench"','length': 0,'name': 'Trench','precision': 0,'type': 2},
                    {'expression': '"Type"','length': 0,'name': 'Type','precision': 0,'type': 10},
                    {'expression': '"Category"','length': 0,'name': 'Category','precision': 0,'type': 10},
                    {'expression': '"Length"','length': 0,'name': 'Length (m)','precision': 3,'type': 6},
                    {'expression': '"Width"','length': 0,'name': 'Width (m)','precision': 3,'type': 6},
                    {'expression': '"Depth"','length': 0,'name': 'Depth (m)','precision': 3,'type': 6},
                    {'expression': '"Plan"','length': 0,'name': 'Plan','precision': 0,'type': 10},
                    {'expression': '"Section_Sheet"','length': 0,'name': 'Section Sheet','precision': 0,'type': 10},
                    {'expression': '"Section"','length': 0,'name': 'Section','precision': 0,'type': 10},
                    {'expression': '"Additional_Sections"','length': 0,'name': 'Additional Sections','precision': 0,'type': 10},
                    #create a Description Field that sum all description fields (long field)
                    {'expression': combined_description_express,'length': 255,'name': 'Description','precision': 0,'type': 10},
                    #
                    {'expression': '"Stratigraphically_above"','length': 0,'name': 'Stratigraphically_above','precision': 0,'type': 10},
                    {'expression': '"Stratigraphically_below"','length': 0,'name': 'Stratigraphically_below','precision': 0,'type': 10},
                    #photos
                    {'expression': '"Camera_set_number"','length': 0,'name': 'Camera Set Number','precision': 0,'type': 10},
                    {'expression': '"Photo_numbers"','length': 0,'name': 'Photo Numbers','precision': 0,'type': 10},
                    #used for cut description. Keep them? Add a selectable option
                    # {'expression': '"Shape"','length': 0,'name': 'Shape','precision': 0,'type': 10},
                    # {'expression': '"Sides"','length': 0,'name': 'Sides','precision': 0,'type': 10},
                    # {'expression': '"Base"','length': 0,'name': 'Base','precision': 0,'type': 10},
                    # {'expression': '"Orientation"','length': 0,'name': 'Orientation','precision': 0,'type': 10},
                    #
                    {'expression': '"Cuts"','length': 0,'name': 'Cuts','precision': 0,'type': 10},
                    {'expression': '"Cut_by"','length': 0,'name': 'Cut by','precision': 0,'type': 10},
                    {'expression': '"Number_of_fills"','length': 0,'name': 'Number of fills','precision': 0,'type': 10},
                    {'expression': '"Interpretation"','length': 0,'name': 'Interpretation','precision': 0,'type': 10},
                    #postex data
                    {'expression': '"Group"','length': 254,'name': 'Group','precision': 0,'type': 10},
                    {'expression': '"Entity"','length': 254,'name': 'Entity','precision': 0,'type': 10},
                    {'expression': '"Period"','length': 254,'name': 'Period','precision': 0,'type': 10},
                    {'expression': '"Period Number"','length': 254,'name': 'Period Number','precision': 0,'type': 10},
                    {'expression': '"Sub Period"','length': 254,'name': 'Sub-Period','precision': 0,'type': 10},
                    {'expression': '"Sub Period Number"','length': 254,'name': 'Sub-Period Number','precision': 0,'type': 10},
                    {'expression': '"Phase"','length': 254,'name': 'Phase','precision': 0,'type': 10},
                    # used for fill description. Keep them? Add a selectable option
                    # {'expression': '"Compaction"','length': 0,'name': 'Compaction','precision': 0,'type': 10},
                    # {'expression': '"Tone"','length': 0,'name': 'Tone','precision': 0,'type': 10},
                    # {'expression': '"Hue"','length': 0,'name': 'Hue','precision': 0,'type': 10},
                    # {'expression': '"Colour"','length': 0,'name': 'Colour','precision': 0,'type': 10},
                    # {'expression': '"Composition"','length': 0,'name': 'Composition','precision': 0,'type': 10},
                    # {'expression': '"Significant_ Inclusions"','length': 0,'name': 'Significant_ Inclusions','precision': 0,'type': 10},
                    #
                    {'expression': '"Fill_Sequence"','length': 0,'name': 'Fill Sequence','precision': 0,'type': 10},
                    {'expression': '"Same_as"','length': 0,'name': 'Same as','precision': 0,'type': 10},
                    {'expression': '"Equivalent_to"','length': 0,'name': 'Equivalent to','precision': 0,'type': 10},
                    {'expression': '"Formation"','length': 0,'name': 'Formation','precision': 0,'type': 10},
                    #
                    {'expression': '"Enviro_samples"','length': 0,'name': 'Enviro_samples','precision': 0,'type': 10},
                    {'expression': '"Other_samples"','length': 0,'name': 'Other_samples','precision': 0,'type': 10},
                    {'expression': '"Finds"','length': 0,'name': 'Finds','precision': 0,'type': 10},
                    {'expression': '"Small_Finds"','length': 0,'name': 'Small_Finds','precision': 0,'type': 10},
                    {'expression': '"Provisional_dating"','length': 0,'name': 'Provisional dating','precision': 0,'type': 10},
                    {'expression': '"Additional_comments"','length': 0,'name': 'Other comments','precision': 0,'type': 10},
                    #cremation##
                    {'expression': '"Cremation_type"','length': 0,'name': 'Cremation_type','precision': 0,'type': 10},
                    {'expression': '"Cremation_truncation"','length': 0,'name': 'Cremation_truncation','precision': 0,'type': 10},
                    {'expression': '"Urn_Number"','length': 0,'name': 'Urn_Number','precision': 0,'type': 10},
                    {'expression': '"Crem_grave_goods"','length': 0,'name': 'Crem_grave_goods','precision': 0,'type': 10},
                    #skeleton
                    {'expression': '"Head_at"','length': 0,'name': 'Head_at','precision': 0,'type': 10},
                    {'expression': '"Skeleton_attitude"','length': 0,'name': 'Skeleton_attitude','precision': 0,'type': 10},
                    {'expression': '"Head"','length': 0,'name': 'Head','precision': 0,'type': 10},
                    {'expression': '"Right_arm"','length': 0,'name': 'Right_arm','precision': 0,'type': 10},
                    {'expression': '"Left_arm"','length': 0,'name': 'Left_arm','precision': 0,'type': 10},
                    {'expression': '"Right_leg"','length': 0,'name': 'Right_leg','precision': 0,'type': 10},
                    {'expression': '"Left_leg"','length': 0,'name': 'Left_leg','precision': 0,'type': 10},
                    {'expression': '"Feet"','length': 0,'name': 'Feet','precision': 0,'type': 10},
                    {'expression': '"Skeleton_preservation"','length': 0,'name': 'Skeleton_preservation','precision': 0,'type': 10},
                    #coffin            
                    {'expression': '"Coffin"','length': 0,'name': 'Coffin','precision': 0,'type': 10},
                    {'expression': '"Coffin_number"','length': 0,'name': 'Coffin number','precision': 0,'type': 10},
                    {'expression': '"Coffin_Preservation"','length': 0,'name': 'Coffin Preservation','precision': 0,'type': 10},
                    {'expression': '"Coffin_Description"','length': 0,'name': 'Coffin Description','precision': 0,'type': 10},
                    {'expression': '"Coffin_Dimensions"','length': 0,'name': 'Coffin Dimensions','precision': 0,'type': 10},
                    #masonry
                    {'expression': '"Masonry_structure"','length': 0,'name': 'Masonry_structure','precision': 0,'type': 10},
                    {'expression': '"Materials"','length': 0,'name': 'Materials','precision': 0,'type': 10},
                    {'expression': '"Materials_size"','length': 0,'name': 'Materials_size','precision': 0,'type': 10},
                    {'expression': '"Stones_finish"','length': 0,'name': 'Stones_finish','precision': 0,'type': 10},
                    {'expression': '"Coursing"','length': 0,'name': 'Coursing','precision': 0,'type': 10},
                    {'expression': '"Quoins"','length': 0,'name': 'Quoins','precision': 0,'type': 10},
                    {'expression': '"Form"','length': 0,'name': 'Form','precision': 0,'type': 10},
                    {'expression': '"Faces"','length': 0,'name': 'Faces','precision': 0,'type': 10},
                    {'expression': '"Bonding_material"','length': 0,'name': 'Bonding_material','precision': 0,'type': 10},
                    {'expression': '"Pointing"','length': 0,'name': 'Pointing','precision': 0,'type': 10},
                    {'expression': '"Masonry_dimensions"','length': 0,'name': 'Masonry_dimensions','precision': 0,'type': 10},
                    {'expression': '"Associated_contexts"','length': 0,'name': 'Associated_contexts','precision': 0,'type': 10},
                    #timber
                    {'expression': '"Timber_structure"','length': 0,'name': 'Timber_structure','precision': 0,'type': 10},
                    {'expression': '"Timber_type"','length': 0,'name': 'Timber_type','precision': 0,'type': 10},
                    {'expression': '"Setting"','length': 0,'name': 'Setting','precision': 0,'type': 10},
                    {'expression': '"Timber_orientation"','length': 0,'name': 'Timber_orientation','precision': 0,'type': 10},
                    {'expression': '"Cross_section"','length': 0,'name': 'Cross_section','precision': 0,'type': 10},
                    {'expression': '"Conversion"','length': 0,'name': 'Conversion','precision': 0,'type': 10},
                    {'expression': '"Condition"','length': 0,'name': 'Condition','precision': 0,'type': 10},
                    {'expression': '"Timber_dimensions"','length': 0,'name': 'Timber_dimensions','precision': 0,'type': 10},
                    {'expression': '"Tool_marks"','length': 0,'name': 'Tool_marks','precision': 0,'type': 10},
                    {'expression': '"Joints_and_fittings"','length': 0,'name': 'Joints_and_fittings','precision': 0,'type': 10},
                    {'expression': '"Intentional_marks"','length': 0,'name': 'Intentional_marks','precision': 0,'type': 10},
                    {'expression': '"Surface_treatment"','length': 0,'name': 'Surface_treatment','precision': 0,'type': 10},
                    #interesting
                    {'expression': '"Interesting"','length': 0,'name': 'Interesting','precision': 0,'type': 10},
                    {'expression': '"Interesting_reason"','length': 0,'name': 'Interesting_reason','precision': 0,'type': 10},
                    #attachments
                    {'expression': '"Feature_photo"','length': 0,'name': 'Feature_photo','precision': 0,'type': 10},
                    {'expression': '"Sketch_plan"','length': 0,'name': 'Sketch_plan','precision': 0,'type': 10},
                    #recording data
                    {'expression': '"Excavated_by"','length': 0,'name': 'Excavated_by','precision': 0,'type': 10},
                    {'expression': '"Recorded_by"','length': 0,'name': 'Recorded_by','precision': 0,'type': 10},
                    {'expression': '"Timestamp"','length': 0,'name': 'Timestamp','precision': 0,'type': 10},
                    {'expression': '"fid"','length': 0,'name': 'GIS_fid','precision': 0,'type': 2}
                    ]
                
                if table_to_export.name() == 'DRS_Trench_sheet':
                    DRS_Field_scheme = [
                    {'expression': "'"+sitecode+"'",'length': 100,'name': 'Site Code','precision': 0,'type': 10},
                    {'expression': '"Trench_Number"','length': 0,'name': 'Trench Number','precision': 0,'type': 2},
                    {'expression': '"Trench1_Orientation"','length': 0,'name': 'Alignment','precision': 0,'type': 10},
                    {'expression': '"Trench_Length"','length': 0,'name': 'Length (m)','precision': 2,'type': 6},
                    {'expression': '"Trench_Width"','length': 0,'name': 'Width (m)','precision': 2,'type': 6},
                    {'expression': '"Maximum_trench_depth_(m)"','length': 0,'name': 'Max Machine depth (m)','precision': 3,'type': 6},
                    ###add an expression to retrieve the level from levels
                    {'expression': '','length': 0,'name': 'Level of Natural (m OD)','precision': 3,'type': 6},
                    #not on original table
                    {'expression': '"Topsoil_description"','length': 0,'name': 'Topsoil_description','precision': 0,'type': 10},
                    {'expression': '"Subsoil_description"','length': 0,'name': 'Subsoil_description','precision': 0,'type': 10},
                    {'expression': '"Natural_description"','length': 0,'name': 'Natural_description','precision': 0,'type': 10},
                    #end1
                    {'expression': '"End_1_Location"','length': 0,'name': 'End 1 Location','precision': 0,'type': 10}, 
                    {'expression': '"Topsoil_thickness_End_1_(m)"','length': 0,'name': 'Topsoil thickness End 1 (m)','precision': 0,'type': 10},#ok
                    {'expression': '"Subsoil_Thickness_End_1_(m)"','length': 0,'name': 'Subsoil Thickness End 1 (m)','precision': 0,'type': 10},
                    #insert expression
                    {'expression': '','length': 0,'name': 'Natural depth End 1 (m OD)','precision': 3,'type': 6},
                    # #end2
                    {'expression': '"End_2_Location"','length': 0,'name': 'End_2_Location','precision': 0,'type': 10},
                    {'expression': '"Topsoil_thickness_End_2_(m)"','length': 0,'name': 'Topsoil thickness End 2 (m)','precision': 0,'type': 10},
                    {'expression': '"Subsoil_Thickness_End_2_(m)"','length': 0,'name': 'Subsoil Thickness End 2 (m)','precision': 0,'type': 10},
                    #insert expression
                    {'expression': '','length': 0,'name': 'Natural depth End 2 (m OD)','precision': 3,'type': 6},
                    {'expression': '"Layers"','length': 0,'name': 'Layers','precision': 0,'type': 10},
                    #archaeology
                    {'expression': '"Archaeology_Presence"','length': 0,'name': 'Archaeology Presence','precision': 0,'type': 10},
                    {'expression': '"Finds"','length': 0,'name': 'Finds','precision': 0,'type': 10},
                    ########## to check##########
                    #Create an expression that count the features and retieve the features typology from DRS and count them 
                    #insert expression
                    {'expression': '','length': 0,'name': 'Summary of Archaeological Features','precision': 0,'type': 10},
                    #photos
                    {'expression': '"DSLR_camera_set_number"','length': 0,'name': 'DSLR camera set number','precision': 0,'type': 10},
                    {'expression': '"DSLR_photo_numbers"','length': 0,'name': 'DSLR photo numbers','precision': 0,'type': 10},
                    #attachments
                    {'expression': '"Trench_photo"','length': 0,'name': 'Trench photo','precision': 0,'type': 10},
                    {'expression': '"Sketch_plan"','length': 0,'name': 'Sketch plan','precision': 0,'type': 10},
                    #recorded
                    {'expression': '"Recorded_by"','length': 0,'name': 'Recorded by','precision': 0,'type': 10},
                    {'expression': '"Timestamp"','length': 0,'name': 'Timestamp','precision': 0,'type': 10},
                    {'expression': '"fid"','length': 0,'name': 'GISfid','precision': 0,'type': 6}
                    ]


                
                #CSVT_list_types = '''"String","Integer","Integer","Integer","String","String""Real","Real","Real","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","Integer"'''
                
                CSVT_list_types = []
                for e in DRS_Field_scheme:
                    if e["type"] == 2:
                        CSVT_list_types.append('Integer')
                    if e["type"] == 6:
                        CSVT_list_types.append('Real')
                    if e["type"] == 10:
                        CSVT_list_types.append('String')
                    
                
                CSVT_list_types_string = (','.join('"' + item + '"' for item in CSVT_list_types))
                
                
                if not os.path.exists(str(path+'/'+filename+'_'+now +'.csvt')):
                    f = open(str(path+'/'+filename+'_'+now +'.csvt'), "w")
                    
                    f.write(CSVT_list_types_string)
                    f.close() 

                

                processing.runAndLoadResults("native:refactorfields", 
                {'INPUT':table_to_export,
                'FIELDS_MAPPING':DRS_Field_scheme,
              
                'OUTPUT': str(path+'/'+filename+'_'+now +'.csv')})
                
                
           
                os.startfile(path)
                #iface.messageBar().pushMessage('PCA Geomax Survey Processing Plugin:', 'Manually delete the folder "Processed_shapefiles" and re-run the plugin', level=Qgis.Info)   
                   
      
        
                
        
    def dontdonothing(self):
        pass
