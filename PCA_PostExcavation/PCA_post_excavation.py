# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PCAPostExcavation                                           A QGIS plugin
                                 
 PCA Post-excavation is an internal QGIS Plugin specifically built for
 the PCA post-excavation phase.
 
 It is a component of the new DRS/GIS integrated data management system,
 and provides a set of tools that help definings groups, entities, periods,
 sub-periods and phases for all the archeological features.
	  
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-10-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Valerio Pinna (Pre-Construct Archaeology)
        email                : vpinna@pre-construct.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import re
import csv
import glob
import time
import shutil
import random
import os.path
import inspect
import processing
import webbrowser
from datetime import date, datetime

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QVariant
from qgis.PyQt.QtGui import QIcon, QKeySequence
from qgis.PyQt.QtWidgets import QAction,QMessageBox, QToolBar, QShortcut, QProgressBar
from qgis.core import *
from qgis.utils import iface
from PyQt5 import QtGui
from PyQt5.QtWidgets import QDialog
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor, QFont

try:
    import pyodbc
except:
    # Define the command to install python-docx
    command = ['pip', 'install', 'pyodbc']
    # Execute the command
    subprocess.call(command)
    import pyodbc

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .PCA_post_excavation_dockwidget import PCAPostExcavationDockWidget


# Import the code for the dialog
from .pca_postex_dialog import PCA_PostExcDialog
from .pca_postex_update_DRS_dialog import PCA_PostExc_updateDRS_Dialog
from .pca_postex_generate_layer_dialog import PCA_PostExc_GenerateLayer_Dialog
from .pca_postex_export_to_access_dialog import PCA_PostExc_ExportToAccess_Dialog
from .pca_postex_update_Interventions_dialog import PCA_PostExc_updateInterventions_Dialog
from .pca_postex_choose_style_dialog import PCA_PostExc_ChooseStyle_Dialog
from .pca_postex_ChooseDRSUpdateStep_dialog import PCA_PostExc_ChooseDRSUpdateStep_Dialog

first_use = []
cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]

class PCAPostExcavation:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PCAPostExcavation_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&PCA Post Excavation')
        
        
        # # TODO: We are going to let the user set this up in a future iteration
        # self.toolbar = self.iface.addToolBar(u'PCAPostExcavation')
        # self.toolbar.setObjectName(u'PCAPostExcavation')
        
        self.actions = []
        self.menu = self.tr(u'&PCA PostExcavation')
        

        #print "** INITIALIZING PCAPostExcavation"
        
        
        
         # Test ## Add dialogues istances
        #self.dlg = PCA_PostExcDialog()        
        
        
        #self.dlg = PCAPostExcavationDockWidget() 
        self.dockwidget = PCAPostExcavationDockWidget()
        self.dlgtool2 = PCA_PostExc_updateInterventions_Dialog()
        self.dlgtool3 = PCA_PostExc_GenerateLayer_Dialog()
        self.dlgtool4 = PCA_PostExc_ExportToAccess_Dialog()
        self.dlgtool5 = PCA_PostExc_updateDRS_Dialog()
        self.dlgtool6 = PCA_PostExc_ChooseStyle_Dialog()
        self.dlgtool7 = PCA_PostExc_ChooseDRSUpdateStep_Dialog()
        
        
        self.dockwidget.clear_subperiod_pushButton.setVisible(False) 
        self.dockwidget.clear_phase_pushButton.setVisible(False)           
        
        
        self.toolbar = iface.mainWindow().findChild( QToolBar, u'PCA PostExcavation Toolbar' )
        if not self.toolbar:
            self.toolbar = iface.addToolBar( u'PCA PostExcavation Toolbar' )
            self.toolbar.setObjectName( u'PCA PostExcavation Toolbar' )
            self.toolbar.setToolTip("")
        
        
        self.dlgtool4.Tables_on_GIS_comboBox.setFilters(QgsMapLayerProxyModel.NoGeometry ) 
        
        self.dockwidget.setStyleSheet("QComboBox"
                                     "{"
                                     "background-color: red;"
                                     "}")
        
        
        

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PCAPostExcavation', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        self.PCAlogo= self.add_action( 
            icon_path = ':/plugins/pca_post_excavation/icons/pca_logo_icon.png',
            text=self.tr(u''),
            callback=self.dontdonothing,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
              
        self.layergeneratoricon= self.add_action( 
            icon_path = ':/plugins/pca_post_excavation/icons/PCA_postex_layer_generator_icon.png',
            text=self.tr(u'Generate the PCA post-excavation layer'),
            callback=self.generate_postex_layer_initial_checks,
            parent=self.iface.mainWindow())     
        # will be set False in generate_postex_layer_initial_checks()
        self.first_start = True
        
        self.changeattributes= self.add_action( 
            icon_path = ':/plugins/pca_post_excavation/icons/PCA_postex_change_attribute_icon.png',
            text=self.tr(u'Add post-excavation attributes to selected features'),
            callback=self.open_dock_change_attributes,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        self.reapply_style= self.add_action( 
            icon_path = ':/plugins/pca_post_excavation/icons/PCA_postex_reapply_style_icon.png',
            text=self.tr(u'Select the style for the Features_for_PostEx layer'),
            callback=self.choose_style,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
   
        self.updateDRS= self.add_action( 
            icon_path = ':/plugins/pca_post_excavation/icons/PCA_postex_update_DRS_icon.png',
            text=self.tr(u'Update the Interventions and the DRS Context Database from the Features_for_postex attribute data'),
            callback=self.choose_DRS_update_step,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
        self.exportforAccess= self.add_action( 
            icon_path = ':/plugins/pca_post_excavation/icons/PCA_postex_export_to_access_icon.png',
            text=self.tr(u'Export a formatted version of the DRS Context Database that can be imported on Access'),
            callback=self.export_table_for_access,
            parent=self.iface.mainWindow())     
        # will be set False in change_attributes()
        self.first_start = True
        
    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING PCAPostExcavation"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD PCAPostExcavation"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&PCA Post Excavation'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def group_names_list(self):
        group_names_list = ['','Ditch', 'Pit Group', 'Animal Burial', 'Cistern', 'Corn Dryer', 'Cremation Burial', 'Deposit', 'Drain', 'Fence Line', 'Flue', 'Foundation', 'Foundation Trench', 'Furnace', 'Furrow', 'Grave', 'Gully', 'Hearth', 'Inhumation Burial', 'Kiln', 'Mound', 'Midden', 'Natural', 'Natural Channels','Oven', 'Pit Alignment', 'Pit Cluster', 'Pond', 'Post Hole', 'Post Packing', 'Post Pad', 'Post Pipe', 'Pyre', 'Quarry', 'Roundhouse', 'SFB', 'Skeleton', 'Stake Hole', 'Structure', 'Surface', 'Surface (external)', 'Surface (internal)', 'Wall', 'Water Hole', 'Well', 'Ungrouped']

        self.dockwidget.group_name_comboBox_2.clear()
        self.dockwidget.group_name_comboBox_2.addItems(group_names_list)
        
    def entity_names_list(self):
        # entity_names_list = ['','Cemetery','Field System','Enclosure', 'Linear Boundary','Road/Trackway','Monument', 'Palaeochannel' ]
        entity_names_list = ['', 'Aisled Barn', 'Boundary', 'Cemetery', 'Cultivation Channels', 'Field System', 'Enclosure', 'Monument', 'Occupation build-up', 'Road/Trackway','Roundhouse', 'Palaeochannel' ]

        
        self.dockwidget.entity_name_comboBox_2.clear()
        self.dockwidget.entity_name_comboBox_2.addItems(entity_names_list)
        
    def period_list(self):
        period_list = ['','Neolithic', 'Bronze Age', 'Iron Age', 'Romano-British', 'Anglo-Saxon', 'Medieval', 'Post Medieval', 'Modern', 'Undated']

        self.dockwidget.period_comboBox_2.clear()
        self.dockwidget.period_comboBox_2.addItems(period_list)

    def subperiod_list_changed(self):
        ch_period = self.dockwidget.period_comboBox_2.currentText()
        global sub_neolithic_list
        sub_neolithic_list = ['','Early Neolithic', 'Middle Neolithic', 'Late Neolithic']
        global sub_bronze_age_list
        sub_bronze_age_list = ['','Early Bronze Age', 'Middle Bronze Age', 'Late Bronze Age']
        global sub_iron_age_list
        sub_iron_age_list = ['','Early Iron Age','Middle Iron Age','Late Iron Age']
        global sub_roman_list
        sub_roman_list = ['','C1 to Early C2', 'C2 to C3','C3 to C4', 'C4 to C5']
        global sub_saxon_list
        sub_saxon_list = ['','Early Anglo-Saxon','Middle Anglo-Saxon','Late Anglo-Saxon']
        global sub_medieval_list
        sub_medieval_list = ['','Anglo-Norman - Early Medieval','High Medieval','Late Medieval']
        global sub_postmedieval_list
        sub_postmedieval_list = ['', 'Early Post Medieval', 'Middle Post Medieval', 'Late Post Medieval']
        global sub_modern_list
        sub_modern_list = ['']
        global undated_list
        undated_list = ['']
        

        if ch_period == 'Neolithic':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_neolithic_list)
            
        if ch_period == 'Bronze Age':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_bronze_age_list)

        if ch_period == 'Iron Age':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_iron_age_list)
        
        if ch_period == 'Romano-British':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_roman_list)
        
        if ch_period == 'Anglo-Saxon':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_saxon_list)
            
        if ch_period == 'Medieval':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_medieval_list)
        
        if ch_period == 'Post Medieval':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_postmedieval_list)
            
        if ch_period == 'Modern':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(sub_modern_list)
            
        if ch_period == 'Undated':
            self.dockwidget.sub_period_comboBox_2.clear()
            self.dockwidget.sub_period_comboBox_2.addItems(undated_list)
                   
    def change_period_number(self):
        ch_period = self.dockwidget.period_comboBox_2.currentText()
        if ch_period == 0:
            return self.dontdonothing
        if ch_period == '':
            self.dockwidget.period_number_comboBox_2.clear()
            self.dockwidget.phase_comboBox_2.setCurrentText('')
            return self.dontdonothing
        else:
            
            period_list = ['Neolithic', 'Bronze Age', 'Iron Age', 'Romano-British', 'Anglo-Saxon', 'Medieval', 'Post Medieval', 'Modern', 'Undated']
            
            if ch_period == 'Undated':
                ch_period_number = ''
            else:
                ch_period_number = str(period_list.index(ch_period)+1)

            ch_period_number_list = []
            ch_period_number_list.append(ch_period_number)
            self.dockwidget.period_number_comboBox_2.clear()
            self.dockwidget.period_number_comboBox_2.addItems(ch_period_number_list)
            self.dockwidget.phase_comboBox_2.setCurrentText('')
            
    def change_subperiod_number(self):
        ch_period = self.dockwidget.period_comboBox_2.currentText()
        period_number = self.dockwidget.period_number_comboBox_2.currentText() 
        ch_subperiod = self.dockwidget.sub_period_comboBox_2.currentText()
        
        if ch_subperiod == 0:
            return self.dontdonothing
        
        else:

            AllItems = [self.dockwidget.sub_period_comboBox_2.itemText(i) for i in range(self.dockwidget.sub_period_comboBox_2.count())]
            if len(AllItems) == 0: 
                return self.dontdonothing
            else:
                if ch_subperiod == '':
                    self.dockwidget.subperiod_number_comboBox_2.clear()
                    self.dockwidget.phase_comboBox_2.setCurrentText('')
                if ch_subperiod != '':
                
                
                    ch_subperiod_number = str(AllItems.index(ch_subperiod))
                    if ch_subperiod_number == 0:
                        return self.dontdonothing
                    else:
                        ch_subperiod_number_final = period_number+'.'+ch_subperiod_number
                        ch_subperiod_number_list = []
                        ch_subperiod_number_list.append(ch_subperiod_number_final)
                        self.dockwidget.subperiod_number_comboBox_2.clear()
                        self.dockwidget.subperiod_number_comboBox_2.addItems(ch_subperiod_number_list)
                        self.dockwidget.phase_comboBox_2.setCurrentText('')                       
                        
    def change_group_number(self, ch_group_name):


        #print ('change number ch_group_name', ch_group_name)
        #print ('change number ch_group_name', len(ch_group_name))
        vlayer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        
        
        if ch_group_name == '':
            self.dockwidget.group_number_comboBox_2.clear()
            
        elif len(ch_group_name) == 0:
            self.dockwidget.group_number_comboBox_2.clear()
        
        elif ch_group_name == 'Ungrouped':
            self.dockwidget.group_number_comboBox_2.clear()
        
        else:
            
            current_value = []
            proposed_group_number_list = []
            filtered_list = []
            
            for s in vlayer.selectedFeatures():
                current_value.append(s["Group"])

            used_group_list = set()
            for f in vlayer.getFeatures():
                name = f["Group"]
                if name != NULL:
                    used_group_list.add(name)

            for a in used_group_list:
                if a.find(ch_group_name) == 0:
                    filtered_list.append(a)

            list_of_numbers=[]
            for stri in filtered_list:
                list_of_numbers.append([int(s) for s in stri.split() if s.isdigit()])

            if len(list_of_numbers) != 0:
                max_value = max(list_of_numbers)
                for max_va in max_value:
                    next_value = max_va+1
                    proposed_group_number_list.append(str(next_value))        
                    
            if len(list_of_numbers) == 0:
                next_value = '1'
                proposed_group_number_list.append(next_value)
            
            # #if vlayer.selectedFeatureCount() != 0:
            # if current_value and current_value[0] in used_group_list and ch_group_name == "".join(re.sub('\d+', '', current_value[0]).rstrip().lstrip()):
                # proposed_group_number_list.append("".join(re.findall('\d+', current_value[0])))
            
            
            # else:
                # new_group_number = str((len(filtered_list)+1))
                # proposed_group_number_list.append(new_group_number)

            self.dockwidget.group_number_comboBox_2.clear()
            #print ('proposed_group_number_list', proposed_group_number_list)
            self.dockwidget.group_number_comboBox_2.addItems(proposed_group_number_list)  
            
            list_of_numbers.clear()
            used_group_list.clear()
            filtered_list.clear()
            current_value.clear()
             
    def change_entity_number(self, ch_entity_name):
        
        vlayer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        if ch_entity_name == '':
            self.dockwidget.entity_number_comboBox_2.clear()
        if ch_entity_name != '':
        
            entity_current_value = []
            proposed_entity_number_list = []
            entity_filtered_list = []
            
            for s in vlayer.selectedFeatures():
                entity_current_value.append(s["Entity"])
            
            used_entity_list = set()
            for f in vlayer.getFeatures():
                name = f["Entity"]
                if name != NULL:
                    used_entity_list.add(name)
                    
            
            for a in used_entity_list:
                if a.find(ch_entity_name) == 0:
                    entity_filtered_list.append(a)
                    
            list_of_numbers=[]
            for stri in entity_filtered_list:
                list_of_numbers.append([int(s) for s in stri.split() if s.isdigit()])
                
            if len(list_of_numbers) != 0:
                max_value = max(list_of_numbers)
                for max_va in max_value:
                    next_value = max_va+1
                    proposed_entity_number_list.append(str(next_value))
                
   
            if len(list_of_numbers) == 0:
                next_value = '1'
                proposed_entity_number_list.append(next_value)        
                    
                    
            # #if vlayer.selectedFeatureCount() != 0:
            # if entity_current_value and entity_current_value[0] in used_entity_list and ch_entity_name == "".join(re.sub('\d+', '', entity_current_value[0]).rstrip().lstrip()):
                # proposed_entity_number_list.append("".join(re.findall('\d+', entity_current_value[0])))        
            
            # else:
                # new_entity_number = str((len(entity_filtered_list)+1))
                # proposed_entity_number_list.append(new_entity_number)
            
            self.dockwidget.entity_number_comboBox_2.clear()
            self.dockwidget.entity_number_comboBox_2.addItems(proposed_entity_number_list) 
            
            used_entity_list.clear()
            entity_filtered_list.clear()
            entity_current_value.clear()
    
    def generate_postex_layer_initial_checks(self):
        if self.first_start == True:
            self.first_start = False
            
        # show the dialog
        self.dlgtool3.show()
        # Run the dialog event loop
        result = self.dlgtool3.exec_()
        # See if OK was pressed
        if result:
            #add the action here
            
            root = QgsProject.instance().layerTreeRoot()
            if root.findGroup("Site Plan") is None:
                QMessageBox.about(
                None,
                'PCA PostExcavation Plugin',
                '''This is not a valid PCA QGIS Site Plan Project''')
                return self.dontdonothing()
            else:
                pass

            #Geopackage Project Folder
            geopackage_project_path = QgsProject.instance().homePath() + '/Geopackages/PCA_site_plan_geodatabase.gpkg'

             


            #to check if the layer already exists
            layer = QgsVectorLayer(geopackage_project_path,"test","ogr")
            subLayers =layer.dataProvider().subLayers()
                                                
            layer_list_name = []
            
            for subLayer in subLayers:
                layer_name = subLayer.split('!!::!!')[1]
                layer_list_name.append(layer_name)
            

            if 'Features_for_PostEx' in layer_list_name:
                print ('file exist')
            
                reply = QMessageBox.warning(None,  'PCA PostExcavation Plugin',
                                                    '''The layer 'Features_for_PostEx' already exists! \nDo you want to overwrite it? All your previous edits will be lost.''',
                                                    QMessageBox.Yes, QMessageBox.No)
                if reply == QMessageBox.No:
                    print ('file exist but i am not touching it')
                    return self.dontdonothing()
                            
                if reply == QMessageBox.Yes:
                    print ('file exist and...')
                    for lyr in QgsProject.instance().mapLayers().values():
                        if lyr.name() == "Features_for_PostEx":
                            QgsProject.instance().removeMapLayers([lyr.id()])
                            print ('... i removed...')
                            
                            return self.generate_postex_layer_process()
            else:
                print ('file not exist')
                return self.generate_postex_layer_process()
                    
    def generate_postex_layer_process(self): 
        print ('now i am in process')
        root = QgsProject.instance().layerTreeRoot()
        geopackage_project_path = QgsProject.instance().homePath() + '/Geopackages/PCA_site_plan_geodatabase.gpkg'
        output_parameters = "ogr:dbname='"+geopackage_project_path+"'"
        
        #create new group
        for child in root.children():
            sitenamegroup = (child.name())
            if child.findGroup("PostEx") is None:
                child.insertGroup(0, "PostEx")   
    
        
        #merge and generate the new layer
                           
        shapefile_list = []

      
        list_of_layers = ['Archaeological_Features', 'Burials', 'Layers', 'Masonry', 'Modern', 'Furrows_and_Ridges' ]
        for e in list_of_layers:
            if QgsProject.instance().mapLayersByName(e):
                origlayer= QgsProject.instance().mapLayersByName(e)[0]
                origlayer_path = origlayer.source()
                shapefile_list.append(origlayer_path)
        
        parameters = {'LAYERS': shapefile_list, 
                      'CRS': 'EPSG:27700', 
                      'OUTPUT':output_parameters+' table="Features_for_PostEx" (geom)'}
                      
                      #'OUTPUT': str(path+'/Features_for_PostEx.shp')}                
                      

        processing.runAndLoadResults("qgis:mergevectorlayers", parameters) 
            
        
        
        thelayer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
        myblayer = root.findLayer(thelayer.id())
        myClone = myblayer.clone()
        parent = myblayer.parent()
        root.findGroup("PostEx").insertChildNode(1, myClone)
        parent.removeChildNode(myblayer) 

        #expand group
        layeronplace = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        myLayerNode = root.findLayer(layeronplace.id())
        myLayerNode.setExpanded(True)


        #remove fields
        final_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
        caps = final_layer.dataProvider().capabilities()
        
        id_list = []
        fields_list = []
        for field in final_layer.fields():
            fields_list.append(field.name())
        if 'layer' in fields_list:
            fields_list.remove('layer')
        if 'fid' in fields_list:
            fields_list.remove('fid')


        for e in fields_list:
            id_list.append(final_layer.fields().indexFromName(e))


        
        res = final_layer.dataProvider().deleteAttributes(id_list)
        
        
        #add new fields
        
        resadd = final_layer.dataProvider()
        resadd.addAttributes([QgsField('Group', QVariant.String, '', 254),
                              QgsField('Entity', QVariant.String, '', 254),
                              QgsField('Period', QVariant.String, '', 254),
                              QgsField('Period_no', QVariant.String, '', 254),
                              QgsField('SubPeriod', QVariant.String, '', 254),
                              QgsField('SubPer_no', QVariant.String, '', 254),
                              QgsField('Phase', QVariant.String, '', 254),
                              QgsField('Notes', QVariant.String, '', 254)])
          
        
        final_layer.updateFields()  
        
        #add style from file
        
        final_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/PCA_PostExcavation_Features_Style.qml')))    

        iface.mapCanvas().refresh()

        node_group1 = root.findGroup("PostEx")
        node_group1.setExpanded(False) # set as false to remove the false true at the creation
        node_group1.setExpanded(True)
        
        myLayerNode = root.findLayer(final_layer.id())
        myLayerNode.setExpanded(True)

        for e in list_of_layers:
            if QgsProject.instance().mapLayersByName(e):
                origlayer= QgsProject.instance().mapLayersByName(e)[0]
                root.findLayer(origlayer.id()).setItemVisibilityCheckedParentRecursive(False)
        
        
        QgsProject.instance().layerTreeRoot().findGroup(sitenamegroup).setItemVisibilityChecked(True)
        QgsProject.instance().layerTreeRoot().findGroup('Site Plan').setItemVisibilityChecked(True)
        
        
        root.findLayer(final_layer.id()).setItemVisibilityCheckedParentRecursive(False)
        root.findLayer(final_layer.id()).setItemVisibilityCheckedParentRecursive(True)

        
        iface.setActiveLayer(final_layer)
        
        QMessageBox.about(
        None,
        'PCA PostExcavation Plugin',
        '''New Post-Excavation layer successfully generated and ready for use''')        
    
    def open_dock_change_attributes(self):
        """Run method that loads and starts the plugin"""
        
        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING PCAPostExcavation"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = PCAPostExcavationDockWidget()
                

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            
            if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
                QMessageBox.warning(
                None,
                'PCA PostExcavation Plugin',
                'There is not a valid PCA Post-Excavation layer. Use the appropriate tool in this toolbar to generate it and retry.')
                self.pluginIsActive = False
                return self.dontdonothing()
                
            else: 
         
                iface.layerTreeView().currentLayerChanged.connect(self.check_layer)
        
                layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0] 
                layer.selectionChanged.connect(self.activate_apply_button)
                
                
                #self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
                self.iface.addTabifiedDockWidget(Qt.RightDockWidgetArea, self.dockwidget, raiseTab=True)
                
                self.dockwidget.show()
                iface.mainWindow().showFullScreen()
                iface.mainWindow().showMaximized()
                ####added for test#####
                self.dockwidget.setEnabled(False)
                
               
                return self.configure_dock()
    
    def open_pdf_chronology(self):
        pdf_path = os.path.join(
            self.plugin_dir,
            'resources',
            'PCA_Chronological Period Table_2022_02.pdf')
        
        
        webbrowser.open_new(pdf_path)
        # file = r'file://C:\Users\vpinna\AppData\Roaming\QGIS\QGIS3\profiles\PCA_Default\python\plugins\pca_post_excavation\resources\PCA_Chronological Period Table_2022_01.pdf'
        # edge_path = 'C:/Program Files (x86)/Microsoft/Edge/Application/msedge.exe %s'
        # WB = webbrowser.get(edge_path)
        # WB.open_new(file)
       
    def configure_dock(self):   
        self.period_list()
        self.group_names_list()
        self.entity_names_list()

        self.dockwidget.period_comboBox_2.currentTextChanged.connect(self.subperiod_list_changed)
        self.dockwidget.period_comboBox_2.currentTextChanged.connect(self.change_period_number)
        self.dockwidget.sub_period_comboBox_2.currentTextChanged.connect(self.change_subperiod_number)
        self.dockwidget.group_name_comboBox_2.currentTextChanged.connect(self.change_group_number)
        self.dockwidget.entity_name_comboBox_2.currentTextChanged.connect(self.change_entity_number)
        self.dockwidget.apply_attribute_pushButton.clicked.connect(self.apply_change_on_attributes)
        self.dockwidget.open_pdf_pushButton.clicked.connect(self.open_pdf_chronology)
        

        self.dockwidget.clear_subperiod_pushButton.clicked.connect(self.clear_selected_subperiods)
        self.dockwidget.clear_phase_pushButton.clicked.connect(self.clear_selected_phases) 
               
        
        
        ############
        #first_use = []
        if 'Used' in first_use:
            print ('present')
        #if self.dockwidget.isVisible() == True
        else:
            return self.first_checks()
         
    def first_checks(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                            
            layer = iface.activeLayer()                  
            if layer is not None:
                if layer.type() != QgsVectorLayer.VectorLayer:
                    return self.dontdonothing()
                if layer.type() == QgsVectorLayer.VectorLayer: 
                    if layer.name() == 'Features_for_PostEx':
                        self.dockwidget.setEnabled(True)
                        if layer.selectedFeatureCount() != 0:
                            self.dockwidget.apply_attribute_pushButton.setEnabled(True)
                            return self.retrievevalues()
                        if layer.selectedFeatureCount() == 0:
                            self.dockwidget.apply_attribute_pushButton.setEnabled(False)
                            return self.clean_attributes()
                    else:
                        self.dockwidget.setEnabled(False)
      
    def check_layer(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                            
            layer = iface.activeLayer()                  
            if layer is not None:
                if layer.type() != QgsVectorLayer.VectorLayer:
                    return self.dontdonothing()
 
                if layer.type() == QgsVectorLayer.VectorLayer: 
                    if layer.name() == 'Features_for_PostEx':
                        self.dockwidget.setEnabled(True)
                        return self.activate_apply_button()
                    else:
                        self.dockwidget.setEnabled(False)               
            
    def activate_apply_button(self):
        layers_list = QgsProject.instance().mapLayers()
        
        if len(layers_list)!= 0:                            
            layer = iface.activeLayer()                  
            if layer is not None:
                if layer.type() != QgsVectorLayer.VectorLayer:
                    return self.dontdonothing()
                if layer.type() == QgsVectorLayer.VectorLayer: 
                    if layer.name() == 'Features_for_PostEx':
                        if layer.selectedFeatureCount() != 0:
                            self.dockwidget.apply_attribute_pushButton.setEnabled(True)
                            return self.retrievevalues()
                        if layer.selectedFeatureCount() == 0:
                            self.dockwidget.apply_attribute_pushButton.setEnabled(False)
                            #print ('zero selection')
                            return self.clean_attributes()
                   
    def cleancomboBoxColour(self):
        self.dockwidget.group_number_comboBox_2.setStyleSheet("QComboBox"
                                                                 "{"
                                                                 ""
                                                                 "}")
        self.dockwidget.group_name_comboBox_2.setStyleSheet("QComboBox"
                                                             "{"
                                                             ""
                                                             "}")
        self.dockwidget.entity_number_comboBox_2.setStyleSheet("QComboBox"
                                                             "{"
                                                             ""
                                                             "}")
        self.dockwidget.entity_name_comboBox_2.setStyleSheet("QComboBox"
                                                             "{"
                                                             ""
                                                             "}") 
        self.dockwidget.period_comboBox_2.setStyleSheet("QComboBox"
                                                                 "{"
                                                                 ""
                                                                 "}")                                                                 
        self.dockwidget.period_number_comboBox_2.setStyleSheet("QComboBox"
                                                                 "{"
                                                                 ""
                                                                 "}")       
        self.dockwidget.sub_period_comboBox_2.setStyleSheet("QComboBox"
                                                                 "{"
                                                                 ""
                                                                 "}") 
        self.dockwidget.subperiod_number_comboBox_2.setStyleSheet("QComboBox"
                                                                 "{"
                                                                 ""
                                                                 "}")
        self.dockwidget.phase_comboBox_2.setStyleSheet("QComboBox"
                                                                 "{"
                                                                 ""
                                                                 "}")
        self.dockwidget.multigroup_label.setText('')
        self.dockwidget.multientity_label.setText('')
        self.dockwidget.multiperiod_label.setText('')
        self.dockwidget.multisubperiod_label.setText('')
        self.dockwidget.multiphase_label.setText('')
        self.dockwidget.clear_subperiod_pushButton.setVisible(False)
        self.dockwidget.clear_phase_pushButton.setVisible(False) 

    def apply_change_on_attributes(self):

        first_use.clear()
        
        layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        
            
        period = self.dockwidget.period_comboBox_2.currentText()
        subperiod = self.dockwidget.sub_period_comboBox_2.currentText()
        period_number = self.dockwidget.period_number_comboBox_2.currentText()         
        subperiod_number = self.dockwidget.subperiod_number_comboBox_2.currentText()         
        group_name = self.dockwidget.group_name_comboBox_2.currentText()         
        group_number = self.dockwidget.group_number_comboBox_2.currentText()       
        entity_name = self.dockwidget.entity_name_comboBox_2.currentText()         
        entity_number = self.dockwidget.entity_number_comboBox_2.currentText()  
        phase = self.dockwidget.phase_comboBox_2.currentText()        
         
        
        group_value = group_name+' '+group_number
        
        entity_value = entity_name+' '+entity_number
        
        period_field_idx = layer.fields().indexOf('Period')
        period_new_value = period

        sub_period_field_idx = layer.fields().indexOf('SubPeriod')
        sub_period_new_value = subperiod
        
        period_number_field_idx = layer.fields().indexOf('Period_no')
        period_number_new_value = period_number
        
        sub_period_number_field_idx = layer.fields().indexOf('SubPer_no')
        sub_period_number_new_value = subperiod_number
        
        group_field_idx = layer.fields().indexOf('Group')
        group_new_value = group_value
        
        entity_field_idx = layer.fields().indexOf('Entity')
        
        phase_field_idx = layer.fields().indexOf('Phase')

        layer.startEditing()
        for feat in layer.selectedFeatures():
            feat_id = feat.id()
  
            if len(group_value) > 3:
                #for feat_id in layer.selectedFeatureIds():
                layer.changeAttributeValue(feat_id, group_field_idx, group_new_value)

            if len(entity_value) > 3:
                #for feat_id in layer.selectedFeatureIds():
                layer.changeAttributeValue(feat_id, entity_field_idx, entity_value) 
            
            #period don't change
            if len(period_new_value)!= 0 and feat['Period'] == period_new_value:
                # no period value because being the same means that it didn't change
                
                if len(period_number_new_value) != 0:
                    layer.changeAttributeValue(feat_id, period_number_field_idx, period_number_new_value)

                # options for when the period is the same and change only the subperiod to zero value
                # value present - or because is the only value or because has been added manually
                if len(sub_period_new_value) != 0: 
                    layer.changeAttributeValue(feat_id, sub_period_field_idx, sub_period_new_value)
                    layer.changeAttributeValue(feat_id, sub_period_number_field_idx, sub_period_number_new_value)
                    
                  
                
                #value empty + different from current attribute value + value is empty not because of the multiple value selection
                if len(sub_period_new_value) == 0 and feat['SubPeriod'] != sub_period_new_value and len(self.dockwidget.multisubperiod_label.text()) < 1: 
                    layer.changeAttributeValue(feat_id, sub_period_field_idx, sub_period_new_value)#it should be empty and same as ''
                    layer.changeAttributeValue(feat_id, sub_period_number_field_idx, sub_period_number_new_value)
                
                layer.changeAttributeValue(feat_id, phase_field_idx, phase)
                print ('phase option 2')                

                ## button Clean Sub Periods for option when two or more features with different values are selected and the user wants to remove all the subperiod from the attribute table
            
            
            
            
            #period change
            if len(period_new_value)!= 0 and feat['Period'] != period_new_value:
                
                # phase option 1 - period change so phase is removed
                layer.changeAttributeValue(feat_id, phase_field_idx, phase)
                print ('phase option 1')
                    
                
          
                if len(sub_period_new_value) == 0: 
                    layer.changeAttributeValue(feat_id, sub_period_field_idx, '')
                if len(sub_period_new_value) != 0: 
                    layer.changeAttributeValue(feat_id, sub_period_field_idx, sub_period_new_value)
                    
                if len(sub_period_number_new_value) == 0: 
                    layer.changeAttributeValue(feat_id, sub_period_number_field_idx, '')
                if len(sub_period_number_new_value) != 0: 
                    layer.changeAttributeValue(feat_id, sub_period_number_field_idx, sub_period_number_new_value)
                
                
                
                
                
                #period for last to avoid interference with the others
                if len(period_new_value) != 0: 
                    layer.changeAttributeValue(feat_id, period_field_idx, period_new_value)
                if len(period_number_new_value) != 0:
                    layer.changeAttributeValue(feat_id, period_number_field_idx, period_number_new_value)    
                    
                    
                    
            


            
                
            # if period AND subperiod are both compilated then...
            if feat['Period'] != '' and feat['Period'] != NULL and feat['SubPeriod'] != '' and feat['SubPeriod'] != NULL:
               
                #only one feature selected or many with same value (so label <1 )
                if len(self.dockwidget.multiphase_label.text())< 1:
                    #if phase value is not empty 
                    if len(phase) != 0:
                        layer.changeAttributeValue(feat_id, phase_field_idx, phase)
                        
                    #if phase value is empty (never compiled or manually deleted)
                    if len(phase) == 0:
                        layer.changeAttributeValue(feat_id, phase_field_idx, '')
                
                #many feature selected with many values (so label >1 )
                if len(self.dockwidget.multiphase_label.text())>1:
                    #if phase value is not empty, so added manually
                    if len(phase) != 0:
                        layer.changeAttributeValue(feat_id, phase_field_idx, phase)
                    
                   #if phase value is empty, so multivalues are present
                    ##add Clear phase button
            
            
            #final check on attribute table        
            # if period OR subperiods are empty phase must be empty
            
                
            if period_new_value == 'Undated':
                layer.changeAttributeValue(feat_id, sub_period_field_idx, '')
                layer.changeAttributeValue(feat_id, period_number_field_idx, '')
                layer.changeAttributeValue(feat_id, sub_period_number_field_idx, '')
                layer.changeAttributeValue(feat_id, phase_field_idx, '')   

            # if period_new_value == 'Modern':
                # layer.changeAttributeValue(feat_id, sub_period_field_idx, '')
                # layer.changeAttributeValue(feat_id, sub_period_number_field_idx, '')
                # if feat['Phase'] != NULL:
                    # if len(feat['Phase']) != 0:
                        # if feat['Phase'][0] != '8':
                            # print (feat['Phase'])
                            # layer.changeAttributeValue(feat_id, phase_field_idx, '')   
                
        layer.commitChanges()
        # layer.startEditing()
        # if feat['Period'] == '' or feat['Period'] == NULL or feat['SubPeriod'] == '' or feat['SubPeriod'] == NULL:
                
                # print (feat['Period'])
                # print (feat['SubPeriod'])
                # #layer.changeAttributeValue(feat_id, phase_field_idx, '')
                
                # print ('final clean applied')
        
        # layer.commitChanges()
        
        layer.removeSelection()
        
        
        first_use.append('Used')
        return self.clean_attributes()

    def retrievevalues(self):
        try:
            layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        except:
            return self.dontdonothing()
                
        else:
            
        
            #group
            group_values = []
            for feat in layer.selectedFeatures():
                if layer.selectedFeatures() != 0:
                    group_value = feat['Group']
                    if group_value == NULL:
                        if '_EMPTY VALUES' not in group_values:
                            group_values.append('_EMPTY VALUES') 
                    if group_value != NULL:
                        if group_value not in group_values:
                            group_values.append(group_value)    

            if len(group_values) > 1:
                self.dockwidget.group_name_comboBox_2.setCurrentText('')
                self.dockwidget.group_number_comboBox_2.setCurrentText('')
                self.dockwidget.group_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                self.dockwidget.group_name_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                multiple_groups = ', ' .join(str(e) for e in sorted(group_values))
                self.dockwidget.multigroup_label.setText(multiple_groups)
                
                
            if len(group_values) == 1:         
                existent_group_name = "".join(re.sub('\d+', '', group_values[0]).rstrip().lstrip())
                existent_group_number = "".join(re.findall('\d+', group_values[0]))

                if existent_group_name == '_EMPTY VALUES':
                    existent_group_name = ''
                    
                self.dockwidget.group_name_comboBox_2.setCurrentText(existent_group_name)
                self.dockwidget.group_number_comboBox_2.setCurrentText(existent_group_number)
                self.dockwidget.group_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.group_name_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.multigroup_label.setText('')
                
            #entity
            entity_values = []
            for feat in layer.selectedFeatures():
                if layer.selectedFeatures() != 0:
                    entity_value = feat['Entity']
                    if entity_value == NULL:
                        if '_EMPTY VALUES' not in entity_values:
                            entity_values.append('_EMPTY VALUES') 
                    if entity_value != NULL:
                        if entity_value not in entity_values:
                            entity_values.append(entity_value)    

            if len(entity_values) > 1:
                self.dockwidget.entity_name_comboBox_2.setCurrentText('')
                self.dockwidget.entity_number_comboBox_2.setCurrentText('')
                self.dockwidget.entity_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                self.dockwidget.entity_name_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                
                multiple_entities = ', ' .join(str(e) for e in sorted(entity_values))
                self.dockwidget.multientity_label.setText(multiple_entities)
                
            if len(entity_values) == 1:         
                existent_entity_name = "".join(re.sub('\d+', '', entity_values[0]).rstrip().lstrip())
                existent_entity_number = "".join(re.findall('\d+', entity_values[0]))

                if existent_entity_name == '_EMPTY VALUES':
                    existent_entity_name = ''

                self.dockwidget.entity_name_comboBox_2.setCurrentText(existent_entity_name)
                self.dockwidget.entity_number_comboBox_2.setCurrentText(existent_entity_number)
                self.dockwidget.entity_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.entity_name_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.multientity_label.setText('')
                                                                     
            #period
            period_values = []
            for feat in layer.selectedFeatures():
                if layer.selectedFeatures() != 0:
                    period_value = feat['Period']
                    if period_value == NULL or period_value == '':
                        if '_EMPTY VALUES' not in period_values:
                            period_values.append('_EMPTY VALUES')
                    if period_value != NULL and period_value != '':
                        if period_value not in period_values:
                            period_values.append(period_value)    

            if len(period_values) > 1:
                self.dockwidget.period_comboBox_2.setCurrentText('')
                
                self.dockwidget.period_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                self.dockwidget.period_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                multiple_periods = ', ' .join(str(e) for e in sorted(period_values))
                self.dockwidget.multiperiod_label.setText(multiple_periods)
                

            
            if len(period_values) == 1:
                existent_period_value = (period_values[0])

                if existent_period_value  == '_EMPTY VALUES':
                    existent_period_value = ''
            
                self.dockwidget.period_comboBox_2.setCurrentText(existent_period_value)        
                #self.dockwidget.period_comboBox_2.setCurrentText(period_values[0])
                self.dockwidget.period_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.period_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.multiperiod_label.setText('')
                

            #subperiod
            subperiod_values = []
            for feat in layer.selectedFeatures():
                if layer.selectedFeatures() != 0:
                    subperiod_value = feat['SubPeriod']
                    if subperiod_value == NULL or subperiod_value == '':
                        if '_EMPTY VALUES' not in subperiod_values:
                            subperiod_values.append('_EMPTY VALUES')
                    if subperiod_value != NULL and subperiod_value != '':
                        if subperiod_value not in subperiod_values:
                            subperiod_values.append(subperiod_value)    

            if len(subperiod_values) > 1:
                self.dockwidget.sub_period_comboBox_2.setCurrentText('')
                
                self.dockwidget.sub_period_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                self.dockwidget.subperiod_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                multiple_subperiods = ', ' .join(str(e) for e in sorted(subperiod_values))
                self.dockwidget.multisubperiod_label.setText(multiple_subperiods)
                self.dockwidget.clear_subperiod_pushButton.setVisible(True) 
                
            if len(subperiod_values) == 1:

                existent_subperiod_value = (subperiod_values[0])

                if existent_subperiod_value  == '_EMPTY VALUES':
                    existent_subperiod_value = ''      
                    
                self.dockwidget.sub_period_comboBox_2.setCurrentText(existent_subperiod_value)
                self.dockwidget.sub_period_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.subperiod_number_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.multisubperiod_label.setText('')
                self.dockwidget.clear_subperiod_pushButton.setVisible(False)
                
            
            #phase
            phase_values = []
            for feat in layer.selectedFeatures():
                if layer.selectedFeatures() != 0:
                    phase_value = feat['Phase']
                    if phase_value == NULL or phase_value == '':
                        if '_EMPTY VALUES' not in phase_values:
                            phase_values.append('_EMPTY VALUES')
                    if phase_value != NULL and phase_value != '':
                        if phase_value not in phase_values:
                            phase_values.append(phase_value)
                    
            phase_values_copy = phase_values.copy()
            if '_EMPTY VALUES' in phase_values_copy:
                phase_values_copy.remove('_EMPTY VALUES')

            if len(phase_values) > 1 and len(phase_values_copy) != 0:
                self.dockwidget.phase_comboBox_2.setCurrentText('')
                
                self.dockwidget.phase_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     "background-color: #ffcccc;"
                                                                     "}")
                multiple_phases = ', ' .join(str(e) for e in sorted(phase_values))
                self.dockwidget.multiphase_label.setText(multiple_phases)
                self.dockwidget.clear_phase_pushButton.setVisible(True)
                
                
                 
                
            if len(phase_values) == 1 and '_EMPTY VALUES' not in phase_values:         
                self.dockwidget.phase_comboBox_2.setCurrentText(phase_values[0])
                self.dockwidget.phase_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.multiphase_label.setText('')
                self.dockwidget.clear_phase_pushButton.setVisible(False)
                
                
            if len(phase_values) == 1 and '_EMPTY VALUES' in phase_values:
                self.dockwidget.phase_comboBox_2.setStyleSheet("QComboBox"
                                                                     "{"
                                                                     ""
                                                                     "}")
                self.dockwidget.multiphase_label.setText('')
                self.dockwidget.clear_phase_pushButton.setVisible(False)
            
    def clean_attributes(self):
        
        #print('clean')
        
        ##clean
        self.dockwidget.group_number_comboBox_2.clear()
        self.dockwidget.group_name_comboBox_2.clear()   
        self.dockwidget.entity_number_comboBox_2.clear()
        self.dockwidget.period_number_comboBox_2.clear()
        self.dockwidget.period_comboBox_2.clear() 
        self.dockwidget.sub_period_comboBox_2.clear() 
        self.dockwidget.subperiod_number_comboBox_2.clear() 
        self.dockwidget.entity_name_comboBox_2.clear() 
        self.dockwidget.phase_comboBox_2.clear()
        self.dockwidget.phase_comboBox_2.addItems([''])

        ##configure
        self.period_list()
        self.group_names_list()
        self.entity_names_list()

        return self.cleancomboBoxColour()
    
    def clear_selected_phases(self):
       
        layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        
        phase_field_idx = layer.fields().indexOf('Phase')
        
        reply = QMessageBox.warning(None,  'PCA PostExcavation Plugin',
                                            '''Do you really want to clean all the phases for the selected features?''',
                                            QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.No: 
            return self.dontdonothing()
                    
        if reply == QMessageBox.Yes:
            layer.startEditing()
            for feat in layer.selectedFeatures():
            
                feat_id = feat.id()
     
                layer.changeAttributeValue(feat_id, phase_field_idx, '')

            layer.commitChanges()     
            return self.retrievevalues()
            
    def clear_selected_subperiods(self):
       
        layer = QgsProject.instance().mapLayersByName('Features_for_PostEx')[0]
        
        sub_period_field_idx = layer.fields().indexOf('SubPeriod')
        sub_period_number_field_idx = layer.fields().indexOf('SubPer_no')
        phase_field_idx = layer.fields().indexOf('Phase')
        
        reply = QMessageBox.warning(None,  'PCA PostExcavation Plugin',
                                            '''Do you really want to clean all the subperiods for the selected features?''',
                                            QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.No: 
            return self.dontdonothing()
                    
        if reply == QMessageBox.Yes:
            layer.startEditing()
            for feat in layer.selectedFeatures():
            
                feat_id = feat.id()
     
                layer.changeAttributeValue(feat_id, sub_period_field_idx, '')
                layer.changeAttributeValue(feat_id, sub_period_number_field_idx, '')
                layer.changeAttributeValue(feat_id, phase_field_idx, '')

            layer.commitChanges()     
            return self.retrievevalues()     
   
    def choose_style(self):
        self.dlgtool6.raise_()

        self.dlgtool6.show()
        # Run the dialog event loop
        #result = self.dlgtool6.exec_()
        # See if OK was pressed
        #if result:
        self.dlgtool6.full_periods_pushButton.clicked.connect(self.reapply_period_style)
        self.dlgtool6.filtered_periods_pushButton.clicked.connect(self.clean_empty_rules)
        self.dlgtool6.combined_periods_phases_pushButton.clicked.connect(self.combined_periods_phases_style)
        self.dlgtool6.groups_pushButton.clicked.connect(self.apply_groups_style)
        self.dlgtool6.entities_pushButton.clicked.connect(self.apply_entity_style)
        
    def apply_groups_style(self):
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else: 
            restyle_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            restyle_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/PCA_PostExcavation_Groups_Style.qml')))    
            
            
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode = root.findLayer(restyle_layer.id())
            myLayerNode.setExpanded(True)
            
            # self.dlgtool6.groups_radioButton.setAutoExclusive(False)
            # self.dlgtool6.groups_radioButton.setChecked(False)
            
            restyle_layer.triggerRepaint()
            restyle_layer.emitStyleChanged()            
            iface.mapCanvas().refresh()
            
    def reapply_period_style(self):
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else: 
            restyle_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            restyle_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/PCA_PostExcavation_Features_Style.qml')))    
            
            
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode = root.findLayer(restyle_layer.id())
            myLayerNode.setExpanded(True)
            
            # self.dlgtool6.full_periods_radioButton.setAutoExclusive(False)
            # self.dlgtool6.full_periods_radioButton.setChecked(False)
            
            restyle_layer.triggerRepaint()
            restyle_layer.emitStyleChanged()            
            iface.mapCanvas().refresh()
            
    def clean_empty_rules(self):
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else:
            restyle_layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            restyle_layer.loadNamedStyle(os.path.join(os.path.join(cmd_folder, 'qml/PCA_PostExcavation_Features_Style.qml')))    
            
            
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode = root.findLayer(restyle_layer.id())
            myLayerNode.setExpanded(True)
            
            
            r = restyle_layer.renderer()
            if r.type() == 'RuleRenderer':
                for rule in r.rootRule().children(): # Iterate rules
                    if rule.filter(): # Filter out empty rules
                        request = QgsFeatureRequest( rule.filter() )
                        count = len( [f for f in restyle_layer.getFeatures( request )] )
                        if count == 0:
             
                            r.rootRule().removeChild(rule)

            restyle_layer.triggerRepaint() 
            iface.layerTreeView().refreshLayerSymbology( restyle_layer.id() )
            restyle_layer.emitStyleChanged()
            iface.mapCanvas().refresh()

    def combined_periods_phases_style(self):
        
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else: 
            layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]
            
            #Symbology
            phasing_set = set()
            phasing_list = []
            phasing_classes = {}

            for e in layer.getFeatures():
                if e['Period'] == NULL or e['Period'] == '' :
                    per = ''
                else:
                    per = e['Period']
                if e['Period_no'] == NULL or e['Period_no'] == '' :
                    per_no = ''
                else:
                    per_no = e['Period_no']
                if e['SubPer_no'] == NULL or e['SubPer_no'] == '' :
                    subper_no = ''
                else:
                    subper_no = e['SubPer_no']
                if e['SubPeriod'] == NULL:
                    subper = ''
                else:
                    subper = e['SubPeriod']
                if e['Phase'] == NULL:
                    phase = ''
                else:
                    phase = e['Phase']

                e_string = ''
                if per_no != '':
                    e_string1 = '{} {}'.format(per_no, per)
                    e_string = e_string + e_string1
                
                if subper_no != '':
                    e_string2 = ' - {} {}'.format(subper_no, subper)
                    e_string = e_string + e_string2
                if phase != '':
                    e_string3 = ' - {}'.format(phase)
                    e_string = e_string + e_string3
                if e_string != 'NULL NULL':
                    phasing_set.add(e_string)
                
            for u in phasing_set:
                phasing_list.append(u)

            for c in sorted(phasing_list):
                phasing_classes[c]= ("#"+''.join([random.choice('0123456789ABCDEF') for j in range(6)]), c)
                
            phasing_classes['']= ('#cccccc', 'Empty values')

            categories = []
            # Iterate through the dictionary
            for classes, (color, label) in phasing_classes.items():
                # Automatically set symbols based on layer's geometry
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                # Set colour
                symbol.setColor(QColor(color))
                # Set symbol with value = 0 to be transparent
                symbol.setOpacity(0.65)
                # Set the renderer properties
                category = QgsRendererCategory(classes, symbol, label)
                categories.append(category)

            # Field name
            expression = '''
            concat(
                if (Period_no is not Null,
                if (Period_no is not '',

                "Period_no" || ' '||
                "Period",''),'')
                ,
                if (SubPer_no is not Null, 
                if (SubPer_no is not '', 
                ' - '||
                "SubPer_no" ||' '||
                "SubPeriod", ''),'')
                ,
                if (Phase is not Null, 
                if (Phase is not '', 
                 ' - ' ||
                "Phase", ''),'')
                )
            '''
            
            # Set the categorized renderer
            renderer = QgsCategorizedSymbolRenderer(expression, categories)

            layer.setRenderer(renderer)

            root = QgsProject.instance().layerTreeRoot()
            myLayerNode = root.findLayer(layer.id())
            myLayerNode.setExpanded(True)

            #Labels           
            layer_settings  = QgsPalLayerSettings()
            layer_settings.fieldName = ''
            layer_settings.enabled = False

            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            layer.setLabelsEnabled(False)
            layer.setLabeling(layer_settings)
            
            # Refresh layer
            layer.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology( layer.id() )
            layer.emitStyleChanged()
            iface.mapCanvas().refresh()          

    def natural_sort(self, l): 
            convert = lambda text: int(text) if text.isdigit() else text.lower()
            alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
            return sorted(l, key=alphanum_key)

    def apply_entity_style(self):
        if len(QgsProject.instance().mapLayersByName('Features_for_PostEx')) == 0:
            return self.dontdonothing
        else: 
            layer = QgsProject.instance().mapLayersByName("Features_for_PostEx")[0]

            #Symbology
            entities_list = []
            entities_classes = {}

            for e in layer.getFeatures():
                entity = e['Entity']   
                
                if entity != NULL:
                    if entity not in entities_list:
                        entities_list.append(entity)
            sorted_entities_list = self.natural_sort(entities_list)

            for c in sorted_entities_list:
                entities_classes[c]= ("#"+''.join([random.choice('0123456789ABCDEF') for j in range(6)]), c)
                
            entities_classes['']= ('#cccccc', 'Empty values')

            categories = []
            # Iterate through the dictionary
            for classes, (color, label) in entities_classes.items():
                # Automatically set symbols based on layer's geometry
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                # Set colour
                symbol.setColor(QColor(color))
                # Set symbol with value = 0 to be transparent
                symbol.setOpacity(0.65)
                # Set the renderer properties
                category = QgsRendererCategory(classes, symbol, label)
                categories.append(category)

            # Field name
            expression = '"Entity"'
            # Set the categorized renderer
            renderer = QgsCategorizedSymbolRenderer(expression, categories)

            layer.setRenderer(renderer)

            # Refresh layer
            layer.triggerRepaint()
            iface.layerTreeView().refreshLayerSymbology( layer.id() )
            layer.emitStyleChanged()
            iface.mapCanvas().refresh()


            root = QgsProject.instance().layerTreeRoot()
            myLayerNode = root.findLayer(layer.id())
            myLayerNode.setExpanded(True)
            
            #Labels
            
            layer_settings  = QgsPalLayerSettings()
            text_format = QgsTextFormat()

            text_format.setFont(QFont("Arial", 8))
            text_format.setSize(8)

            buffer_settings = QgsTextBufferSettings()
            buffer_settings.setEnabled(True)
            buffer_settings.setSize(1)
            buffer_settings.setColor(QColor("white"))
            buffer_settings.setOpacity(0.6)

            text_format.setBuffer(buffer_settings)
            layer_settings.setFormat(text_format)

            layer_settings.fieldName = "Entity"
            layer_settings.placement = 2

            layer_settings.enabled = True

            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            layer.setLabelsEnabled(True)
            layer.setLabeling(layer_settings)
            layer.triggerRepaint()

    def choose_DRS_update_step(self):
        self.dlgtool7.show()
        # if self.first_start == True:
           # self.first_start = False
        self.dlgtool7.update_intervention_pushButton.clicked.connect(self.update_intervention_from_features)
        self.dlgtool7.update_DRS_pushButton.clicked.connect(self.from_intervention_to_DRS)
        
    def update_intervention_from_features(self):
        # if self.first_start == True:
            # self.first_start = False

        # show the dialog
        self.dlgtool2.show()
        # Run the dialog event loop
        result = self.dlgtool2.exec_()
        # See if OK was pressed
        if result:            
            if len(QgsProject.instance().mapLayersByName('Interventions')) == 0:
                QMessageBox.about(
                None,
                'PCA PostExcavation Plugin',
                '''This is not a valid PCA QGIS Site Plan Project''')
                return self.dontdonothing()
                
            if len(QgsProject.instance().mapLayersByName('Interventions')) != 0:

                intervention_DRS_layer = QgsProject.instance().mapLayersByName("Interventions")[0]
            
                #Create progress bar
                progressMessageBar = iface.messageBar().createMessage("Intervention layer is being updated...")
                progress = QProgressBar()
                progress.setMaximum(100)
                progress.setAlignment(Qt.AlignLeft|Qt.AlignVCenter)
                progressMessageBar.layout().addWidget(progress)
                iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
                
                progress.setValue(0)
  
                #check if the group exists and, if not, create it
                caps = intervention_DRS_layer.dataProvider().capabilities()    
                resadd = intervention_DRS_layer.dataProvider()
                            
                group_field_name_list = ["Group","Entity", "Period", "Period Number", "Sub Period","Sub Period Number","Phase"]

                for group_name in group_field_name_list:
                    group_field_name = group_name
                    field_index = intervention_DRS_layer.fields().indexFromName(group_name)
                    if field_index == -1:
                        resadd.addAttributes([QgsField(group_name, QVariant.String, '', 254)])
                    

                intervention_DRS_layer.updateFields()  
                progress.setValue(20)
                time_value = 20
                #############################

                #add the attributes to Intervention from Features_for_PostEx

                intervention_DRS_layer.startEditing()

                for group_name in group_field_name_list:

                    if group_name == "Period Number":
                        group_name_contract = "Period_no"
                    elif group_name == 'Sub Period':
                        group_name_contract = 'SubPeriod'
                    elif group_name == 'Sub Period Number':
                        group_name_contract = 'SubPer_no'
                    else:
                        group_name_contract = group_name

                    ###old expression. Creates duplicated value if a slot is below two features (es. ditch and layer) and a false result if a slot has two interventions (es, old cut below all)
                    # e = QgsExpression( '''\
                    # array_to_string(\
                    # array_majority( \
                    # aggregate(\
                    # layer:='Features_for_PostEx',\
                    # aggregate:='array_agg',\
                    # expression:='''+group_name_contract+''',\
                    # filter:=intersects($geometry,buffer(geometry(@parent),-0.1))\
                    # )))\
                    # ''' )
                    ####
                    
                    e = QgsExpression( '''
                    array_to_string(
                    array_majority( 
                    aggregate(
                    layer:='Features_for_PostEx',
                    aggregate:='array_agg',
                    expression:='''+group_name_contract+''',\
                    filter:=intersects(boundary(buffer($geometry, -0.01)), geometry(@parent))
                    )))
                    ''')

                    context = QgsExpressionContext()
                    context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(intervention_DRS_layer))

                    for f in intervention_DRS_layer.getFeatures():
                        context.setFeature(f)
                        f[group_name] = e.evaluate( context )
                        intervention_DRS_layer.updateFeature(f)
                    time_value += 10
                    progress.setValue(time_value)
                    
                intervention_DRS_layer.commitChanges()
                
                #self.dlgtool2.hide()                
                iface.messageBar().clearWidgets()
                
                QMessageBox.about(None,'PCA PostExcavation Plugin', '''The Intervention layer has been successfully updated.<br><br><strong>NB</strong>: Before running the step 2, check the Interventions attribute data and, if required, edit and complete the data.''')
                #QMessageBox.about(None,'PCA PostExcavation Plugin', 'The Intervention layer has been successfully updated.')
                self.dlgtool2.close()
                self.dlgtool7.close()
                
                

    def from_intervention_to_DRS(self):
        # show the dialog
        self.dlgtool5.show()
        # Run the dialog event loop
        result = self.dlgtool5.exec_()
        # See if OK was pressed
        if result:

            ##starting calculating processing time
            time0= datetime.now()
        
            if len(QgsProject.instance().mapLayersByName('Interventions')) == 0:
                QMessageBox.about(
                None,
                'PCA PostExcavation Plugin',
                '''This is not a valid PCA QGIS Site Plan Project''')
                return self.dontdonothing()
                
            if len(QgsProject.instance().mapLayersByName('Interventions')) != 0:
                # if len(QgsProject.instance().mapLayersByName('DRS_Table')) != 0:
                    # DRS_to_update = QgsProject.instance().mapLayersByName('DRS_Table')[0]
                    
                # Attempt to get the layer from the project
                layers = QgsProject.instance().mapLayersByName('DRS_Context_Database')

                if layers:
                    # Layer found, assign the first layer
                    layer = layers[0]
                else:
                    # Layer doesn't exist, assign another layer or handle the error
                    layers = QgsProject.instance().mapLayersByName('DRS_Table')
                    
                    if layers:
                        layer = layers[0]
                    else:
                        # Neither layer exists, handle the error
                        layer = None

                if not layer:
                    QMessageBox.about(None,'PCA PostExcavation Plugin', 'The current project doen\'t contains any valid DRS Context Database.')
                    return self.dontdonothing()
                if layer:
                    DRS_to_update = layer  
                                    
                    context_list = []
                    for f in DRS_to_update.getFeatures():
                        context_list.append(f['Context'])
                        
                    if NULL in context_list:
                        QMessageBox.about(None,'PCA PostExcavation Plugin', 'The DRS Context Database contains one or more NULL values in the Context field. Please fix them and retry.')
                        return self.dontdonothing()
                    if NULL not in context_list:
                        cut_list = []
                        for f in DRS_to_update.getFeatures():
                            cut_list.append(f['Cut'])
                        
                        if NULL in cut_list:
                            QMessageBox.about(None,'PCA PostExcavation Plugin', 'The DRS Context Database contains one or more NULL values in the Cut field. Please fix them and retry.')
                            return self.dontdonothing()
                        
                        if NULL not in cut_list:

                            #Create progress bar
                            progressMessageBar = iface.messageBar().createMessage("DRS Context Database is being updated...")
                            progress = QProgressBar()
                            progress.setMaximum(100)
                            progress.setAlignment(Qt.AlignLeft|Qt.AlignVCenter)
                            progressMessageBar.layout().addWidget(progress)
                            iface.messageBar().pushWidget(progressMessageBar, Qgis.Info)
                            
                            
                            
                            progress.setValue(0)
                            
                            group_field_name_list = ["Group","Entity", "Period", "Period Number", "Sub Period","Sub Period Number","Phase"]
                            intervention = QgsProject.instance().mapLayersByName('Interventions')[0]
                            
                            #build adn populate Intervention Dict    
                            dict = {}
                            for f in intervention.getFeatures():
                                key = f['context_no']
                                dict.setdefault(key, []).append(f['Group'])
                                dict.setdefault(key, []).append(f['Entity'])
                                dict.setdefault(key, []).append(f['Period'])
                                dict.setdefault(key, []).append(f['Period Number'])
                                dict.setdefault(key, []).append(f['Sub Period'])
                                dict.setdefault(key, []).append(f['Sub Period Number'])
                                dict.setdefault(key, []).append(f['Phase'])
                                
                            #check if DRS has groups or add them
                            caps = DRS_to_update.dataProvider().capabilities()    
                            resadd = DRS_to_update.dataProvider()                   

                            for group_name in group_field_name_list:
                                group_field_name = group_name
                                field_index = DRS_to_update.fields().indexFromName(group_name)
                                if field_index == -1:
                                    resadd.addAttributes([QgsField(group_name, QVariant.String, '', 254)])

                            DRS_to_update.updateFields()  
                            
                            progress.setValue(10)
                            time_value = 10
                            
                            interv_cut_list = []
                            for f_cut in intervention.getFeatures():
                                interv_cut_list.append(str(f_cut['Context_no']))
                            
                            DRS_to_update.startEditing()
                                                       
                            increment = DRS_to_update.featureCount()/90
                            for f in DRS_to_update.getFeatures():
                                cut = f["Cut"]
                                f_id = f.id()
                                #iface.mainWindow().statusBar().showMessage(cut)
                                #print (cut)
                                if cut not in interv_cut_list:
                                    pass
                                if cut  in interv_cut_list:
                                    DRS_to_update.selectByExpression("$id ="+ str(f_id))
                                    
                                                                        
                                    for group_name in group_field_name_list:
                                        group_index = group_field_name_list.index(group_name)
                                        any_group_field_idx = DRS_to_update.fields().indexOf(group_name)
                                        for feat_id in DRS_to_update.selectedFeatureIds():
                                            DRS_to_update.changeAttributeValue(feat_id, any_group_field_idx, dict[int(cut)][group_index])
                                            
                                            time_value += increment
                                            progress.setValue(time_value)

                            DRS_to_update.commitChanges()
 
                            #self.dlgtool5.hide()
                            iface.messageBar().clearWidgets()
                            ##ending time
                            time1= datetime.now()
                            ##duration
                            delta = time1-time0

                            time = delta.total_seconds()
                            print ('Time is {} seconds'.format(time))
                            
                            QMessageBox.about(None,'PCA PostExcavation Plugin', 'The DRS Context Database has been successfully updated.')
                            self.dlgtool5.close()
                            self.dlgtool7.close()
                                 
    def export_table_for_access(self):
            # show the dialog
        self.dlgtool4.show()
        # Run the dialog event loop
        result = self.dlgtool4.exec_()
        # See if OK was pressed
        if result:
            table_to_export = self.dlgtool4.Tables_on_GIS_comboBox.currentLayer()
            #AccessDB_to_update = self.dlgtool4.Access_database_mQgsFileWidget.filePath()
            
            if table_to_export is None:
                QMessageBox.about(None,'PCA PostExcavation Plugin', 'No valid DRS Context Database was selected. Please select a layer.')
                return self.dontdonothing()
             
            else:
                sitecode =  self.dlgtool4.sitecode_textbox.text()
                filename =  table_to_export.name()
                now = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                # Directory
                CSV_export_directory = "Exported_DRS_to_CSV"

                #Project Folder
                project_dir = QgsProject.instance().homePath() + '/Databases/'

                path = os.path.join(project_dir,CSV_export_directory)

                if not os.path.exists(path):
                    os.makedirs(path)
                else:
                    pass
              
                combined_description_express ='''
                if("Type"='Cut', 
                concat("Shape",', ',replace(lower(regexp_replace("Sides",' ([(].*?[)])','')),',',' and'),' sides',', ',lower("Base"),' base', if( "Orientation" not ilike  'N/A' or  "Orientation" not ilike  NULL , concat(' and ', "Orientation", ' aligned'), ''))
                ,
                concat("Compaction",' ',lower("Tone"),' ',lower("Hue"),' ' ,lower("Colour"),' ',lower("Composition"),
                if("Significant_ Inclusions" is not null, ' with ', ''),lower("Significant_ Inclusions")))
                '''
                
                finds_pottery_check = '''if("Finds" ilike '%pottery%', 'yes','')'''
                finds_bone_check = '''if("Finds" ilike '%Animal Bone%', 'yes','')'''
                finds_flint_check = '''if("Finds" ilike '%flint%', 'yes','')'''
                
                length_check_and_fix = '''if(length(  "Length" )<> 0,  "Length" , 0)'''
                width_check_and_fix = '''if(length(  "Width" )<> 0,  "Width" , 0)'''
                depth_check_and_fix = '''if(length(  "Depth" )<> 0,  "Depth" , 0)'''
                
                interpretation_field = '''concat( "Interpretation","Formation")'''
                
                
                if table_to_export.name() == 'DRS_Context_Database' or table_to_export.name() == 'DRS_Table':
                    DRS_Field_scheme = [
                    ##add sitecode as first field
                    {'expression': "'"+sitecode+"'",'length': 100,'name': 'Site Code','precision': 0,'type': 10}, #string
                    {'expression': '"Context"','length': 0,'name': 'Context No','precision': 0,'type': 2}, #Integer
                    {'expression': '"Cut"','length': 0,'name': 'Cut','precision': 0,'type': 2}, #Integer
                    {'expression': '"Trench"','length': 0,'name': 'Trench','precision': 0,'type': 10},
                    {'expression': '"Type"','length': 0,'name': 'Type','precision': 0,'type': 10},
                    {'expression': '"Category"','length': 0,'name': 'Category','precision': 0,'type': 10},
                    {'expression': length_check_and_fix,'length': 0,'name': 'Length (m)','precision': 3,'type': 6},
                    {'expression': width_check_and_fix,'length': 0,'name': 'Width (m)','precision': 3,'type': 6},
                    {'expression': depth_check_and_fix,'length': 0,'name': 'Depth (m)','precision': 3,'type': 6},
                    {'expression': '"Plan"','length': 0,'name': 'Plan','precision': 0,'type': 10}, #string
                    # {'expression': '"Section_Sheet"','length': 0,'name': 'Section Sheet','precision': 0,'type': 10}, #string
                    {'expression': '"Section"','length': 0,'name': 'Section','precision': 0,'type': 10}, #string
                    {'expression': '"Additional_Sections"','length': 0,'name': 'Additional Sections','precision': 0,'type': 10},#string
                    #create a Description Field that sum all description fields (long field)
                    {'expression': combined_description_express,'length': 255,'name': 'Description','precision': 0,'type': 10}, #string
                    #
                    # {'expression': '"Stratigraphically_above"','length': 0,'name': 'Stratigraphically_above','precision': 0,'type': 10}, #string
                    # {'expression': '"Stratigraphically_below"','length': 0,'name': 'Stratigraphically_below','precision': 0,'type': 10}, #string
                    #photos
                    # {'expression': '"Camera_set_number"','length': 0,'name': 'Camera Set Number','precision': 0,'type': 10}, #string
                    # {'expression': '"Photo_numbers"','length': 0,'name': 'Photo Numbers','precision': 0,'type': 10}, #string
                    #used for cut description. Keep them? Add a selectable option
                    # {'expression': '"Shape"','length': 0,'name': 'Shape','precision': 0,'type': 10}, #string
                    # {'expression': '"Sides"','length': 0,'name': 'Sides','precision': 0,'type': 10}, #string
                    # {'expression': '"Base"','length': 0,'name': 'Base','precision': 0,'type': 10}, #string
                    # {'expression': '"Orientation"','length': 0,'name': 'Orientation','precision': 0,'type': 10}, #string
                    #
                    {'expression': '"Cuts"','length': 0,'name': 'Cuts','precision': 0,'type': 10}, #string
                    {'expression': '"Cut_by"','length': 0,'name': 'Cut by','precision': 0,'type': 10}, #string
                    {'expression': '"Fill_Sequence"','length': 0,'name': 'Fill Sequence','precision': 0,'type': 10}, #string
                    # {'expression': '"Number_of_fills"','length': 0,'name': 'Number of fills','precision': 0,'type': 10},
                    # {'expression': '"Interpretation"','length': 0,'name': 'Interpretation','precision': 0,'type': 10},
                    {'expression': '"Enviro_samples"','length': 0,'name': 'Enviro Sample','precision': 0,'type': 10}, #string
                    {'expression': finds_flint_check,'length': 0,'name': 'Flint','precision': 0,'type': 10}, #string
                    {'expression': finds_pottery_check,'length': 0,'name': 'Pottery','precision': 0,'type': 10}, #string
                    {'expression': finds_bone_check,'length': 0,'name': 'Bone','precision': 0,'type': 10}, #string
                    {'expression': '"Small_Finds"','length': 0,'name': 'Other significant finds','precision': 0,'type': 10}, #string
                    {'expression': interpretation_field,'length': 0,'name': 'Interpretation','precision': 0,'type': 10}, #string
                    #postex data
                    #{'expression': '','length': 254,'name': 'Feature Name','precision': 0,'type': 10}, #string
                    {'expression': '"Group"','length': 254,'name': 'Group Name','precision': 0,'type': 10}, #string
                    {'expression': '"Entity"','length': 254,'name': 'Entity','precision': 0,'type': 10}, #string
                    {'expression': '"Sub Period"','length': 254,'name': 'Sub-Period Name','precision': 0,'type': 10}, #string
                    {'expression': '"Sub Period Number"','length': 254,'name': 'Sub-Period Number','precision': 0,'type': 10}, #string
                    {'expression': '"Period"','length': 254,'name': 'Period Name','precision': 0,'type': 10}, #string
                    {'expression': '"Period Number"','length': 254,'name': 'Period Number','precision': 0,'type': 10}, #string
                    
                    {'expression': '"Phase"','length': 254,'name': 'Phase','precision': 0,'type': 10}, #string
                    {'expression': '"Additional_comments"','length': 0,'name': 'Other Comments','precision': 0,'type': 10}, #string
                    
                    
                    
                    # used for fill description. Keep them? Add a selectable option
                    # {'expression': '"Compaction"','length': 0,'name': 'Compaction','precision': 0,'type': 10},
                    # {'expression': '"Tone"','length': 0,'name': 'Tone','precision': 0,'type': 10},
                    # {'expression': '"Hue"','length': 0,'name': 'Hue','precision': 0,'type': 10},
                    # {'expression': '"Colour"','length': 0,'name': 'Colour','precision': 0,'type': 10},
                    # {'expression': '"Composition"','length': 0,'name': 'Composition','precision': 0,'type': 10},
                    # {'expression': '"Significant_ Inclusions"','length': 0,'name': 'Significant_ Inclusions','precision': 0,'type': 10},
                    #
                    
                    # {'expression': '"Same_as"','length': 0,'name': 'Same as','precision': 0,'type': 10},
                    # {'expression': '"Equivalent_to"','length': 0,'name': 'Equivalent to','precision': 0,'type': 10},
                    # {'expression': '"Formation"','length': 0,'name': 'Formation','precision': 0,'type': 10},
                    # #
                    
                    # {'expression': '"Other_samples"','length': 0,'name': 'Other_samples','precision': 0,'type': 10},
                    # {'expression': '"Finds"','length': 0,'name': 'Finds','precision': 0,'type': 10},
                    
                    # {'expression': '"Provisional_dating"','length': 0,'name': 'Provisional dating','precision': 0,'type': 10},
                    
                    # #cremation##
                    # {'expression': '"Cremation_type"','length': 0,'name': 'Cremation_type','precision': 0,'type': 10},
                    # {'expression': '"Cremation_truncation"','length': 0,'name': 'Cremation_truncation','precision': 0,'type': 10},
                    # {'expression': '"Urn_Number"','length': 0,'name': 'Urn_Number','precision': 0,'type': 10},
                    # {'expression': '"Crem_grave_goods"','length': 0,'name': 'Crem_grave_goods','precision': 0,'type': 10},
                    # #skeleton
                    # {'expression': '"Head_at"','length': 0,'name': 'Head_at','precision': 0,'type': 10},
                    # {'expression': '"Skeleton_attitude"','length': 0,'name': 'Skeleton_attitude','precision': 0,'type': 10},
                    # {'expression': '"Head"','length': 0,'name': 'Head','precision': 0,'type': 10},
                    # {'expression': '"Right_arm"','length': 0,'name': 'Right_arm','precision': 0,'type': 10},
                    # {'expression': '"Left_arm"','length': 0,'name': 'Left_arm','precision': 0,'type': 10},
                    # {'expression': '"Right_leg"','length': 0,'name': 'Right_leg','precision': 0,'type': 10},
                    # {'expression': '"Left_leg"','length': 0,'name': 'Left_leg','precision': 0,'type': 10},
                    # {'expression': '"Feet"','length': 0,'name': 'Feet','precision': 0,'type': 10},
                    # {'expression': '"Skeleton_preservation"','length': 0,'name': 'Skeleton_preservation','precision': 0,'type': 10},
                    # #coffin            
                    # {'expression': '"Coffin"','length': 0,'name': 'Coffin','precision': 0,'type': 10},
                    # {'expression': '"Coffin_number"','length': 0,'name': 'Coffin number','precision': 0,'type': 10},
                    # {'expression': '"Coffin_Preservation"','length': 0,'name': 'Coffin Preservation','precision': 0,'type': 10},
                    # {'expression': '"Coffin_Description"','length': 0,'name': 'Coffin Description','precision': 0,'type': 10},
                    # {'expression': '"Coffin_Dimensions"','length': 0,'name': 'Coffin Dimensions','precision': 0,'type': 10},
                    # #masonry
                    # {'expression': '"Masonry_structure"','length': 0,'name': 'Masonry_structure','precision': 0,'type': 10},
                    # {'expression': '"Materials"','length': 0,'name': 'Materials','precision': 0,'type': 10},
                    # {'expression': '"Materials_size"','length': 0,'name': 'Materials_size','precision': 0,'type': 10},
                    # {'expression': '"Stones_finish"','length': 0,'name': 'Stones_finish','precision': 0,'type': 10},
                    # {'expression': '"Coursing"','length': 0,'name': 'Coursing','precision': 0,'type': 10},
                    # {'expression': '"Quoins"','length': 0,'name': 'Quoins','precision': 0,'type': 10},
                    # {'expression': '"Form"','length': 0,'name': 'Form','precision': 0,'type': 10},
                    # {'expression': '"Faces"','length': 0,'name': 'Faces','precision': 0,'type': 10},
                    # {'expression': '"Bonding_material"','length': 0,'name': 'Bonding_material','precision': 0,'type': 10},
                    # {'expression': '"Pointing"','length': 0,'name': 'Pointing','precision': 0,'type': 10},
                    # {'expression': '"Masonry_dimensions"','length': 0,'name': 'Masonry_dimensions','precision': 0,'type': 10},
                    # {'expression': '"Associated_contexts"','length': 0,'name': 'Associated_contexts','precision': 0,'type': 10},
                    # #timber
                    # {'expression': '"Timber_structure"','length': 0,'name': 'Timber_structure','precision': 0,'type': 10},
                    # {'expression': '"Timber_type"','length': 0,'name': 'Timber_type','precision': 0,'type': 10},
                    # {'expression': '"Setting"','length': 0,'name': 'Setting','precision': 0,'type': 10},
                    # {'expression': '"Timber_orientation"','length': 0,'name': 'Timber_orientation','precision': 0,'type': 10},
                    # {'expression': '"Cross_section"','length': 0,'name': 'Cross_section','precision': 0,'type': 10},
                    # {'expression': '"Conversion"','length': 0,'name': 'Conversion','precision': 0,'type': 10},
                    # {'expression': '"Condition"','length': 0,'name': 'Condition','precision': 0,'type': 10},
                    # {'expression': '"Timber_dimensions"','length': 0,'name': 'Timber_dimensions','precision': 0,'type': 10},
                    # {'expression': '"Tool_marks"','length': 0,'name': 'Tool_marks','precision': 0,'type': 10},
                    # {'expression': '"Joints_and_fittings"','length': 0,'name': 'Joints_and_fittings','precision': 0,'type': 10},
                    # {'expression': '"Intentional_marks"','length': 0,'name': 'Intentional_marks','precision': 0,'type': 10},
                    # {'expression': '"Surface_treatment"','length': 0,'name': 'Surface_treatment','precision': 0,'type': 10},
                    # #interesting
                    # {'expression': '"Interesting"','length': 0,'name': 'Interesting','precision': 0,'type': 10},
                    # {'expression': '"Interesting_reason"','length': 0,'name': 'Interesting_reason','precision': 0,'type': 10},
                    # #attachments
                    # {'expression': '"Feature_photo"','length': 0,'name': 'Feature_photo','precision': 0,'type': 10},
                    # {'expression': '"Sketch_plan"','length': 0,'name': 'Sketch_plan','precision': 0,'type': 10},
                    # #recording data
                    # {'expression': '"Excavated_by"','length': 0,'name': 'Excavated_by','precision': 0,'type': 10},
                    # {'expression': '"Recorded_by"','length': 0,'name': 'Recorded_by','precision': 0,'type': 10},
                    # {'expression': '"Timestamp"','length': 0,'name': 'Timestamp','precision': 0,'type': 10},
                    # {'expression': '"fid"','length': 0,'name': 'GIS_fid','precision': 0,'type': 2}
                    ]
                
                
                
                
                if table_to_export.name() == 'DRS_Trench_Database' or table_to_export.name() == 'DRS_Trench_sheet':
                    
                    ### to be fixed - doesn't work###
                    '''
                    Probably I must add here a method to create a new field on the DRS Trench Sheet that will be 
                    populated with this expression and then, use this field to export on the summary field
                    '''
                    
                    
                    # archaeology_on_trench = '''
                                            # array_to_string( 
                                            # aggregate(
                                            # layer:='Interventions',
                                            # aggregate:='array_agg',
                                            # expression:=concat("DRS_Category",' [',to_string("Context_no"),']'),
                                            # filter:=contains(geometry(@parent), $geometry)),
                                            # delimiter:=', ')
                                            # '''                    
                    ###
                    
                    DRS_Field_scheme = [
                    {'expression': "'"+sitecode+"'",'length': 100,'name': 'Site Code','precision': 0,'type': 10},
                    {'expression': '"Trench_Number"','length': 0,'name': 'Trench Number','precision': 0,'type': 2},
                    {'expression': '"Trench_Orientation"','length': 0,'name': 'Alignment','precision': 0,'type': 10},
                    {'expression': '"Trench_Length"','length': 0,'name': 'Length (m)','precision': 2,'type': 6},
                    #{'expression': '"Trench_Width"','length': 0,'name': 'Width (m)','precision': 2,'type': 6},
                    {'expression': '"Maximum_trench_depth"','length': 0,'name': 'Max Machine depth (m)','precision': 3,'type': 6},
                    ###add an expression to retrieve the level from levels
                    {'expression': '','length': 0,'name': 'Level of Natural (m OD)','precision': 3,'type': 6},
                    #not on original table
                    #{'expression': '"Topsoil_description"','length': 0,'name': 'Topsoil_description','precision': 0,'type': 10},
                    #{'expression': '"Subsoil_description"','length': 0,'name': 'Subsoil_description','precision': 0,'type': 10},
                    #{'expression': '"Natural_description"','length': 0,'name': 'Natural_description','precision': 0,'type': 10},
                    #end1
                    #{'expression': '"End_1_Location"','length': 0,'name': 'End 1 Location','precision': 0,'type': 10}, 
                    {'expression': '"Topsoil_thickness_End_1"','length': 0,'name': 'Topsoil thickness End 1 (m)','precision': 3,'type': 6},
                    {'expression': '"Subsoil_Thickness_End_1"','length': 0,'name': 'Subsoil thickness End 1 (m)','precision': 3,'type': 6},
                    #insert expression
                    #{'expression': '','length': 0,'name': 'Natural depth End 1 (m OD)','precision': 3,'type': 6},
                    # #end2
                    #{'expression': '"End_2_Location"','length': 0,'name': 'End_2_Location','precision': 0,'type': 10},
                    {'expression': '"Topsoil_thickness_End_2"','length': 0,'name': 'Topsoil thickness End 2 (m)','precision': 3,'type': 6},
                    {'expression': '"Subsoil_Thickness_End_2"','length': 0,'name': 'Subsoil thickness End 2 (m)','precision': 3,'type': 6},
                    #insert expression
                    #{'expression': '','length': 0,'name': 'Natural depth End 2 (m OD)','precision': 3,'type': 6},
                    
                    #{'expression': '"Layers"','length': 0,'name': 'Layers','precision': 0,'type': 10},
                    #archaeology
                    #{'expression': '"Archaeology_Presence"','length': 0,'name': 'Archaeology Presence','precision': 0,'type': 10},
                    #{'expression': '"Finds"','length': 0,'name': 'Finds','precision': 0,'type': 10},
                    ########## to check##########
                    #Create an expression that count the features and retieve the features typology from DRS and count them 
                    #insert expressionLayer
                    {'expression': '','length': 100,'name': 'Summary of Archaeological Features','precision': 0,'type': 10},
                    #photos
                    # {'expression': '"DSLR_camera_set_number"','length': 0,'name': 'DSLR camera set number','precision': 0,'type': 10},
                    # {'expression': '"DSLR_photo_numbers"','length': 0,'name': 'DSLR photo numbers','precision': 0,'type': 10},
                    # #attachments
                    # {'expression': '"Trench_photo"','length': 0,'name': 'Trench photo','precision': 0,'type': 10},
                    # {'expression': '"Sketch_plan"','length': 0,'name': 'Sketch plan','precision': 0,'type': 10},
                    # #recorded
                    # {'expression': '"Recorded_by"','length': 0,'name': 'Recorded by','precision': 0,'type': 10},
                    # {'expression': '"Timestamp"','length': 0,'name': 'Timestamp','precision': 0,'type': 10},
                    # {'expression': '"fid"','length': 0,'name': 'GISfid','precision': 0,'type': 6}
                    ]

                #CSVT_list_types = '''"String","Integer","Integer","Integer","String","String""Real","Real","Real","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","String","Integer"'''
                
                CSVT_list_types = []
                for e in DRS_Field_scheme:
                    if e["type"] == 2:
                        CSVT_list_types.append('Integer')
                    if e["type"] == 6:
                        CSVT_list_types.append('Real')
                    if e["type"] == 10:
                        CSVT_list_types.append('String')
                    
                
                CSVT_list_types_string = (','.join('"' + item + '"' for item in CSVT_list_types))
                
                
                if not os.path.exists(str(path+'/'+filename+'_'+now +'.csvt')):
                    f = open(str(path+'/'+filename+'_'+now +'.csvt'), "w")
                    
                    f.write(CSVT_list_types_string)
                    f.close() 

                file_name = str(path+'/'+filename+'_'+now +'.csv')

                processing.run("native:refactorfields", 
                {'INPUT':table_to_export,
                'FIELDS_MAPPING':DRS_Field_scheme,
              
                'OUTPUT': file_name})
           
                os.startfile(path) # open CSV folder on screen
                
                # ####
                # ### Adding here the automatic updating of the Access database
                # ####
                
                # # Connect to the Access database
                # conn = pyodbc.connect(r'Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ='+AccessDB_to_update+';')

                # # Create a cursor to execute SQL queries
                # cursor = conn.cursor()
                
               
                # if table_to_export.name() == 'DRS_Table':
                
                    # # Clean the table by deleting all existing records
                    # cursor.execute("DELETE FROM [Context List]")  # or "TRUNCATE TABLE YourTableName" for a faster method


                    # ## Open the CSV file
                    # with open(file_name, 'r') as file:
                        # # Create a CSV reader
                        # reader = csv.reader(file)
                       
                        # # Skip the header row
                        # header = next(reader)
                       
                        # # Iterate over each row in the CSV file
                        # for row in reader:
                           
                            # Site_Code,Context_No,Cut,Trench, Type,Category,Length,Width,Depth,Plan,Section,Additional_Sections,Description,Cuts,Cut_by,Fill_Sequence,Enviro_Sample,Flint, Pottery, Bone,Other_significant_finds, Interpretation, Group_Name,Entity, SubPeriod_Name,SubPeriod_Number,Period_Name,Period_Number, Phase, Other_Comments = row
                           
                           
                           
                           
                           # # Convert the Context_No value to an integer
                            # Context_No = int(Context_No)
                            # Cut = int(Cut)
                            # try:
                                # Trench = int(Trench)
                            # except ValueError:
                                # Trench = None
                                
                            # try:
                                # Plan = int(Plan)
                            # except ValueError:
                                # Plan = None
                                
                            # try:
                                # Section = int(Section)
                            # except ValueError:
                                # Section = None
                                
                            # try:
                                # Period_Number = int(Period_Number)
                            # except ValueError:
                                # Period_Number = None
                                
                             # # Insert the values into the Access database
                            # try:
                                # cursor.execute("INSERT INTO [Context List] (\
                                                # [Site Code],[Context No],Cut,Trench, \
                                                # Type,Category,[Length (m)],[Width (m)],[Depth (m)],Plan,Section,\
                                                # [Additional Sections],Description,Cuts,[Cut by],[Fill Sequence],[Enviro Sample],\
                                                # Flint, Pottery, Bone,[Other significant finds],Interpretation,\
                                                # [Group Name],Entity, [Sub-Period Name],[Sub-Period Number], [Period Name],[Period Number], Phase, [Other Comments]\
                                                # )\
                                                # VALUES (?, ?, ?, ?, ?,?, ?, ?, ?, ?,?, ?, ?, ?, ?,?, ?, ?, ?, ?,?, ?, ?, ?, ?,?, ?, ?, ?, ?)",
                                              # Site_Code,Context_No,Cut,Trench, Type,Category,Length,Width,Depth,Plan,Section,Additional_Sections,
                                              # Description,Cuts,Cut_by,Fill_Sequence,Enviro_Sample,Flint, Pottery, Bone, Other_significant_finds, 
                                              # Interpretation, Group_Name, Entity, SubPeriod_Name, SubPeriod_Number, Period_Name, 
                                              # Period_Number, Phase, Other_Comments)

                                
                                # result = True
                               
            
                        
                            
                            # except pyodbc.DataError as e:
                                # print("Data type mismatch error:", e)
                                
                                # result = False
  
                        # conn.commit()

                        # # Close the cursor and connection
                        # cursor.close()
                        # conn.close()
                        
                        # if result == True:
                            # os.startfile(AccessDB_to_update)
                            # QMessageBox.about(None,'PCA PostExcavation Plugin', 'The DRS database {} has been successfully exported into the Access database.'.format(table_to_export.name())) 

                        # if result == False:
                            # QMessageBox.about(None,'PCA PostExcavation Plugin', 'There waa a problem during the exporting of the DRS database {} into Access.\n\nPlease contact the Geospatial data department at\n\ngeospatialdata@pre-construct.com\n\nfor help.'.format(table_to_export.name())) 


                # if table_to_export.name() == 'DRS_Trench_sheet':
                
                    # # Clean the table by deleting all existing records
                    # cursor.execute("DELETE FROM [Trench Table]")  # or "TRUNCATE TABLE YourTableName" for a faster method


                    # ## Open the CSV file
                    # with open(file_name, 'r') as file:
                        # # Create a CSV reader
                        # reader = csv.reader(file)
                       
                        # # Skip the header row
                        # header = next(reader)
                       
                        # # Iterate over each row in the CSV file
                        # for row in reader:
                            # Site_Code, Trench_Number, Alignment,Length, Max_Machine_depth, Level_of_Natural, Topsoil_thickness_End_1, Subsoil_Thickness_End_1, Topsoil_thickness_End_2,Subsoil_thickness_End_2,Summary_of_Archaeological_Features = row

                            # try:
                                # Trench_Number = int(Trench_Number)
                            # except ValueError:
                                # Trench_Number = None
                            
                            # try:
                                # Length = float(Length)
                            # except ValueError:
                                # Length = None
                                
                            # try:
                                # Max_Machine_depth = float(Max_Machine_depth)
                            # except ValueError:
                                # Max_Machine_depth = None
                                
                            # try:
                                # Level_of_Natural = float(Level_of_Natural)
                            # except ValueError:
                                # Level_of_Natural = None
                                
                            # try:
                                # Topsoil_thickness_End_1 = float(Topsoil_thickness_End_1)
                            # except ValueError:
                                # Topsoil_thickness_End_1 = None
                                
                            # try:
                                # Subsoil_Thickness_End_1 = float(Subsoil_Thickness_End_1)
                            # except ValueError:
                                # Subsoil_Thickness_End_1 = None
                                
                            # try:
                                # Topsoil_thickness_End_2 = float(Topsoil_thickness_End_2)
                            # except ValueError:
                                # Topsoil_thickness_End_2 = None
                                
                                
                            # try:
                                # Subsoil_thickness_End_2 = float(Subsoil_thickness_End_2)
                            # except ValueError:
                                # Subsoil_thickness_End_2 = None
                                
                                
                            # #
                            
                            # try:
                                # cursor.execute("INSERT INTO [Trench Table] (\
                                                # [Site Code], [Trench Number],Alignment,[Length (m)], [Max Machine depth (m)], [Level of Natural (m OD)]\
                                                # ,[Topsoil thickness End 1 (m)], [Subsoil Thickness End 1 (m)], [Topsoil thickness End 2 (m)], [Subsoil thickness End 2 (m)]\
                                                # , [Summary of Archaeological Features]\
                                                # )\
                                                # VALUES (?,?,?,?,?,?,?,?,?,?,?)",
                                                
                                                
                                                # Site_Code, Trench_Number,Alignment,Length, Max_Machine_depth, Level_of_Natural
                                                # , Topsoil_thickness_End_1, Subsoil_Thickness_End_1, Topsoil_thickness_End_2,Subsoil_thickness_End_2,
                                                # Summary_of_Archaeological_Features
                                              # )

                                # result = True
                               
            
                        
                            
                            # except pyodbc.DataError as e:
                                # print("Data type mismatch error:", e)
                                
                                # result = False
  
                        # conn.commit()

                        # # Close the cursor and connection
                        # cursor.close()
                        # conn.close()
                        
                        # if result == True:
                            # os.startfile(AccessDB_to_update)
                            # QMessageBox.about(None,'PCA PostExcavation Plugin', 'The DRS database {} has been successfully exported into the Access database.'.format(table_to_export.name())) 

                        # if result == False:
                            # QMessageBox.about(None,'PCA PostExcavation Plugin', 'There waa a problem during the exporting of the DRS database {} into Access.\n\nPlease contact the Geospatial data department at\n\ngeospatialdata@pre-construct.com\n\nfor help.'.format(table_to_export.name())) 


                

    def dontdonothing(self):
        pass
